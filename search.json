[{"title":"Docker + Nginx部署前端项目","url":"/2024/05/10/Docker-Nginx%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/","content":"后端部署可以查看：GitHub Actions &amp; Docker实现自动化部署 | Jin’s Blog (isjinhu.github.io)\n\n\nDocker + Nginx部署前端项目此处省略Docker安装步骤。\nsudo docker run --rm hello-world # 使用该命令可以测试docker是否安装成功\n\nStep 1: 拉取Nginx镜像docker pull nginx # 拉取镜像，没有指定版本会默认下载最新 \n\nStep 2: 创建挂载目录# 注意当前路径切换mkdir -p nginx/htmlmkdir -p nginx/logsmkdir -p nginx/confcd nginxchomd 777 html logs conf\n\nStep 3: 启动一个不挂载的容器docker run -d --name nginx -p 1000:80 nginx\n\n\n--name nginx：指定容器名称\n-p 1000:80 映射端口（宿主机:容器）\n这里可以自选端口，使用lsof -i:1000查看端口是否被占用\n\n\n-d 守护进程运行\n\nStep 4: 拷贝容器内默认配置docker cp nginx:/etc/nginx/nginx.conf nginx/conf/nginx.confdocker cp nginx:/etc/nginx/conf.d nginx/conf/conf.ddocker cp nginx:/usr/share/nginx/html nginx/\n\nStep 5:停止、删除容器docker stop nginx # 停止容器docker rm nginx # 删除容器docker ps -a # 查看所有容器\n\nStep 6: 部署前端项目\n将前端项目目录（vue项目build后的dist目录）上传至nginx/html目录下，并修改nginx/conf.d/default.conf文件。\n\n内容可以参考，其中proxy_pass记得修改为对应部署的后端地址，listen为前端的端口。\n  server {    listen 1001;    location / {        root /usr/share/nginx/html/hmdp;    }    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   /usr/share/nginx/html;    }    location /api {        default_type  application/json;        #internal;        keepalive_timeout   30s;        keepalive_requests  1000;        #支持keep-alive        proxy_http_version 1.1;        rewrite /api(/.*) $1 break;        proxy_pass_request_headers on;        #more_clear_input_headers Accept-Encoding;        proxy_next_upstream error timeout;        proxy_pass http://127.0.0.1:8081;        # proxy_pass http://backend;    }}# upstream backend {#     server 127.0.0.1:80 max_fails=5 fail_timeout=10s weight=1;#     server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;# }\n\nStep 7: 运行镜像，其中-p指定对应的端口映射。docker run \\                  -p 1000:80 \\-p 1001:1001 \\--name nginx \\-v /home/ubuntu/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /home/ubuntu/nginx/conf/conf.d:/etc/nginx/conf.d \\-v /home/ubuntu/nginx/logs:/var/log/nginx \\-v /home/ubuntu/nginx/html:/usr/share/nginx/html \\-d nginx:latest\n\n","categories":["Docker"],"tags":["Docker"]},{"title":"LeetCode刷题笔记：栈&单调栈&单调队列","url":"/2024/05/11/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A0%88-%E5%8D%95%E8%B0%83%E6%A0%88/","content":"栈是一种「先进后出」的数据结构。单调栈是一种特殊的栈，在满足「先进后出」规则基础上，同时满足「从栈底到栈顶的元素单调递增/减」，因此也分为单调递增栈，单调递减栈。\n单调栈用来解决下一个更大/小元素、上一个更大/小元素这一类的典型问题。比如739. 每日温度，84. 柱状图中最大的矩形，42. 接雨水都是这类问题。\n队列是一种「先进先出」的数据结构。单调队列是一种特殊的队列，在满足「先进先出」规则基础上，同时满足「从队首到队尾的元素单调递增/减」。\n单调队列用来解决滑动窗口内的最大/小值、中位数的动态查询这一类问题。比如239. 滑动窗口最大值。\n\n\n单调栈这里以单调递减栈为例，可以解决求下一个更大元素问题。\n单调递减栈的思想是：只有比栈顶元素小的元素才能直接进栈，否则需要将栈中更小的元素出栈。这样，当元素出栈时，就找到了下一个更大元素。\n739. 每日温度 - 中等739. 每日温度：给定一个表示每日温度的整数数组，求对于每天在第几天后温度会比这天更高，如果没有，填0。\n\n输入: temperatures = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n\n思路：求的是下一个更大元素的索引距离，用单调递减栈，栈中记录的实际上是还没算出「下一个更大元素」的数字下标。\n时间复杂度：O(n)，每个元素只进出栈一次。\nclass Solution {    public int[] dailyTemperatures(int[] temperatures) {        int length=temperatures.length;        int[] res=new int[length];        Deque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;(); // 单调栈        for(int i=0;i&lt;length;i++){            while(!stack.isEmpty()&amp;&amp;temperatures[i]&gt;temperatures[stack.peekLast()]){                int j=stack.pollLast();                res[j]=i-j;            }            stack.offerLast(i);        }        // while(!stack.isEmpty()){        //     res[stack.pollLast()]=0;        // }        return res;    }}\n\n84. 柱状图中最大的矩形 - 困难84. 柱状图中最大的矩形：给定柱状图中每个柱子高度，求能勾勒出的矩形最大面积。\n\n\n\n输入：heights = [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10\n\n思路1：想要以某个柱子为高，那么必须知道这个柱子左右侧更矮柱子的下标，即要求更小元素下标。因此用2个单调递增栈，分别求上/下一个更小元素并保存，最后在遍历求面积即可。\n思路2：计算右侧更矮柱子的下标时，单调栈用于维护没有找到右侧更矮柱子的柱子索引，当某个元素出栈时，说明这个元素找到右侧更矮柱子，同时新的栈顶元素（如果存在）一定是当前出栈柱子左侧更矮的柱子。（因为如果左侧有更高的柱子，都已经出栈，而更矮的柱子会留在里面）\nclass Solution {    public int largestRectangleArea(int[] heights) {        Deque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;();        int res=0;        for(int i=0;i&lt;heights.length;i++){            while(!stack.isEmpty()&amp;&amp;heights[i]&lt;heights[stack.peekLast()]){                int curHeight=heights[stack.pollLast()];                int leftIdx=0;                if(!stack.isEmpty()){                    leftIdx=stack.peekLast()+1;                }                int area=curHeight*(i-leftIdx);                res=Math.max(res,area);            }            stack.offerLast(i);        }        while(!stack.isEmpty()){            int curHeight=heights[stack.pollLast()];            int leftIdx=0;            if(!stack.isEmpty()){                leftIdx=stack.peekLast()+1;            }            int area=curHeight*(heights.length-leftIdx);            res=Math.max(res,area);        }        return res;    }}\n\n42. 接雨水 - 困难单调栈做法42. 接雨水\n\n\n思路：当我们找到右侧第一个比某个位置大的元素时，这里就能接水，相当于横着计算。\n\n\nclass Solution {    public int trap(int[] height) {        // 单调栈做法        Deque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;();        int res=0;        for(int i=0;i&lt;height.length;i++){            while(!stack.isEmpty()&amp;&amp;height[stack.peekLast()]&lt;=height[i]){                int curHeight=height[stack.pollLast()];                if(stack.isEmpty()) break;                int left=stack.peekLast();                int h=Math.min(height[left], height[i])-curHeight;                res+=h*(i-left-1);            }            stack.offerLast(i);        }        return res;    }}\n\n双指针做法思路：\n\n某个位置能接的水=min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。\n使用相向双指针遍历分别记录左右两侧当前最大值，其中较小的那个就是公式用到的那个。\n\n时间复杂度：O(n)，空间复杂度：O(1)。\nclass Solution {    public int trap(int[] height){        // 双指针做法: min{lMax, rMax}-h[i], lMax=max{0,...,i}        int res=0;        int left=0, right=height.length-1;        int lMax=height[0], rMax=height[right];        while(left&lt;=right){            if(lMax&lt;rMax){                lMax=Math.max(lMax, height[left]);                res+=lMax-height[left++];            }else{                rMax=Math.max(rMax, height[right]);                res+=rMax-height[right--];            }        }        return res;    }}\n\n单调队列单调队列的思想是：只有当一个元素是最值或者可能成为最值时才保留，否则出队。这样，每次移动窗口时，队首就是当前窗口最值。\n239. 滑动窗口最大值 - 困难239. 滑动窗口最大值\n\n\n思路：对于窗口[1 3 -1]，其中3是最大值，3之前的数字1比3小且更早离开，所以无论窗口如何移动都不会成为最大值，3之后的数字-1比3小但更晚离开，因此可能成为最大值。每次移动时，需要判断队首的最值是否离开窗口，判断队内的旧数字是否还可能成为新的最值，如果比新数字小就不可能，需要出队；否则可能，保留，然后再将新数字入队。\nclass Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        Deque&lt;Integer&gt; queue=new ArrayDeque&lt;&gt;();        int[] res=new int[nums.length-k+1];        // i指向即将入栈的元素，j指向即将出栈的元素        for(int i=0, j=-k+1;i&lt;nums.length;i++,j++){            // 加入新元素，让窗口大小保持为k            while(!queue.isEmpty()&amp;&amp;queue.peekLast()&lt;nums[i]){                queue.pollLast();            }            queue.offerLast(nums[i]); // 入队            if(j&lt;0) continue;            // 计算当前窗口最值            res[j]=queue.peekFirst();            // 移动窗口            if(queue.peekFirst()==nums[j]){                queue.pollFirst();            }        }        return res;    }}\n\n栈：394. 字符串解码394. 字符串解码\nclass Solution {    public String decodeString(String s) {        StringBuilder res=new StringBuilder();        int times = 0;        LinkedList&lt;Integer&gt; timesStack=new LinkedList&lt;&gt;();        LinkedList&lt;String&gt; substrStack=new LinkedList&lt;&gt;();        for(int i=0;i&lt;s.length();i++){            char c=s.charAt(i);            if(c&gt;='0'&amp;&amp;c&lt;='9'){                times=times*10+Integer.parseInt(c+\"\");            }else if(c == '['){                timesStack.add(times);                substrStack.add(res.toString());                times=0;                res=new StringBuilder();            }else if(c==']'){                int curTimes=timesStack.pollLast();                StringBuilder str=new StringBuilder();                while(curTimes--!=0) str.append(res);                res=new StringBuilder(substrStack.pollLast()+str);            }else{                res.append(c);            }        }        return res.toString();    }}\n\n","tags":["LeetCode","算法"]},{"title":"GitHub Pages & Hexo 搭建博客","url":"/2023/08/28/GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","content":"关于如何使用GitHub Pages和Hexo搭建个人博客并进行写作（使用Keep主题）。\n\n\nGitHub Pages &amp; Hexo 搭建博客Hexo 安装与配置\nHexo 安装与配置 | Easy Hexo 👨‍💻\n\n\n确认本地已经安装 Git 和 Node.js\n安装hexo: npm install -g hexo-cli\n在本地创建一个文件夹，然后往这个文件夹中安装Hexo\n配置 Hexo，其配置文件为_config.yml：配置 Hexo | Easy Hexo 👨‍💻\n\nnpm install -g hexo-cli # 安装Hexomkdir mkdir &lt;your_blog_name&gt;  # 建立你的网站根目录，名字可以自己修改hexo init &lt;your_blog_name&gt; # 往这个文件夹中安装Hexo\n\n使用GitHub Pages部署到GitHub\n部署 Hexo | Easy Hexo 👨‍💻\n\nStep 1: 创建一个仓库：.github.io\nStep 2: 在（.github.io）安装部署插件\nnpm install hexo-deployer-git --savenpm install hexo-server --save\n\nStep 3: 部署到 GitHub\nhexo clean &amp;&amp; hexo d -g\n\nGitHub保存博客项目的源代码# 本地博客项目根目录下运行git initgit checkout -b hexo # 切换分支git add .git commit -m \"init\"git remote add origin git@github.com:isJinHu/isjinhu.github.io.git # 添加远程仓库git remote -vgit push origin hexo:hexo # push到远程仓库的hexo分支\n\nKeep主题安装与配置\nhome_article | Keep 主题使用手册 &amp;&amp; XPoet’s Blog\n\nStep 1: 安装Keep主题\ncd &lt;your_blog_name&gt;npm install hexo-theme-keep\n\nStep 2: 使用Keep主题：在 Hexo 配置文件_config.yml 中将 theme 设置为 keep。\ntheme: keep\n\nStep 3：配置Keep主题：在文件夹下创建一个_config.keep.yml文件，参照文档进行配置：base_info | Keep 主题使用指南\n其他：\n\n可能用到的命令：\nnpm install hexo-theme-keep # 安装 keep 主题npm install hexo-filter-mathjax # 安装显示数学公式的插件npm install hexo-generator-searchdb # 安装站内搜索插件npm install hexo-wordcount # 安装统计字数插件hexo new page about # hexo创建页面命令，使用该命令创建about页面。\n\n数学公式 | Keep 主题使用指南：建议开启。\n\n配置时的图标文件可以放在source/images文件夹中。\n\nGitalk设置：comment | Keep 主题使用指南\n\n\n默认博客模板在scaffolds/post.md中可以设置默认模板，比如默认打开公式渲染等。\ntitle: {{ title }}date: {{ date }}mathjax: truetags:\n\n\n\n图片插入：结合TyporaStep 1：修改_config.yml文件\npost_asset_folder: true # 将这个配置项改为true，这样hexo new “postname\"时会创建一个同名文件夹marked:  prependRoot: true  postAsset: true\n\nStep 2：安装插件\nnpm install hexo-asset-img --savenpm install hexo-renderer-marked --save\n\nStep 3: 设置Typora插入图片时路径：${filename}\nHexo deploy失败？\n执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054_copying files from extend dirs…warning: in the w_Candle_light的博客-CSDN博客\n\nhexo config deploy.repository git@github.com:isjinhu/isjinhu.github.io.git\n\n","tags":["GitHub","Hexo"]},{"title":"GitHub Actions & Docker实现自动化部署","url":"/2024/05/10/GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","content":"关于使用GitHub Actions 和 Docker部署SpringBoot后端项目。\n\n\nGitHub Actions + Docker实现自动化部署可以先看一下这个教程：GitHub Actions工作流自动化的入门核心_哔哩哔哩_bilibili\nSpringBoot多环境切换\n参考: 31 SpringBoot多环境的切换(生产环境、开发环境、测试环境)_spring boot生产和开发环境-CSDN博客\n\nStep 1: 在resources/下创建application-dev.yaml和application-prouct.yaml文件，分别表示开发环境和生产环境。\nStep 2: 在两份配置文件中分别自定义配置，例如：\n\n\nStep 3: 在application.yaml文件中引用：\n\n\nStep 4: 激活配置文件：\n\n配置文件：在配置文件中指定spring.profiles.active=dev\n虚拟机参数：在VM options指定 -Dspring.profiles.active=dev\n命令行参数：java -jar xxx.jar –spring.profiles.active=dev\n\nIDEA中使用第二种即可，部署时使用命令行参数指定。\nDockerfile文件编写在项目根目录下，新建Dockerfile，内容如下：\nFROM fabric8/java-alpine-openjdk11-jreENV TZ=Asia/ShanghaiRUN rm -f /etc/localtime \\&amp;&amp; ln -sv /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \\&amp;&amp; echo \"Asia/Shanghai\" &gt; /etc/timezoneCOPY target/*.jar /app.jarENTRYPOINT [\"java\",\"-jar\",\"/app.jar\", \"--spring.profiles.active=product\"]\n\n注意：最后一行指定了配置文件。\nworkflow文件编写以下两种方式二选一即可。\n使用GitHub提供的Ubuntu环境在项目根目录下，新建./github/workflows/delpoy.yml文件，内容如下：\n# 使用Github Actions自动部署Spring Boot项目到服务器name: Deploy With Dockeron:  push:    branches: [ master ]jobs:  build:    name: Build工作    runs-on: ubuntu-latest # 使用GitHub提供的Ubuntu环境    steps:      - name: 读取仓库内容        uses: actions/checkout@v4      - name: 设置Java环境        uses: actions/setup-java@v4        with:          java-version: 11          distribution: 'adopt'          cache: 'maven'      #      - name: 缓存Maven依赖      #        uses: actions/cache@v3      #        with:      #          path: ~/.m2/repository      #          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}      #          restore-keys: |      #            ${{ runner.os }}-maven-      - name: 编译打包        run: mvn package -Dmaven.test.skip=true      - name: 登录到DockerHub        uses: docker/login-action@v3        with:          username: ${{ secrets.DOCKER_USERNAME }}          password: ${{ secrets.DOCKER_PASSWORD }}      - name: 构建Docker镜像        uses: docker/build-push-action@v5        with:          context: .          file: ./Dockerfile          push: true          tags: ${{ secrets.DOCKER_USERNAME }}/project-name:latest      - name: 部署到服务器        uses: appleboy/ssh-action@master        with:          host: ${{ secrets.SERVER_HOST }}          username: ${{ secrets.SERVER_USERNAME }}          port: ${{ secrets.SERVER_PORT }}          password: ${{ secrets.SERVER_PASSWORD }}          script: |            sh /path/to/delpoy.sh\n\nproject-name记得替换为自己的项目名称\n其中deploy.sh脚本内容如下（记得替换{{}}中内容，端口记得按需修改）：\ndocker pull {{username}}/{{project-name}}:latestdocker tag docker.io/{{username}}/{[project-name]}:latest {{project-name}}:latestdocker rm -f {{project-name}}docker run --name {{project-name}} -p 1002:8081 -d {{project-name}}:latestdocker image prune -af\n\nDockerHub记得先注册账号。如果Dockerhub上传的是私密镜像，记得在服务器登录账号：docker login\n在GitHub项目设置中添加yml文件中的secrets，位置如下：\n\n\n使用自己的服务器Step 1: 添加Runner\n\n\nStep 2: 选择服务器对应系统，按照所示步骤在服务器上执行即可：\n\n\n\n其中，运行config.sh脚本记得使用非root用户，否则会报错。\n其次./run.sh命令改为nohup ./run.sh &amp;在后台不挂断运行。\n\nStep 3: 在服务器记得安装maven和Java\nsudo apt updatesudo apt install mavenmvn --version # 验证是否安装成功\n\n\n参考：如何在 Ubuntu 20.04 上安装 Apache Maven-腾讯云开发者社区-腾讯云\n\nStep 4: 在项目创建workflow文件，内容如下：\nname: Deploy With Runneron:  push:    branches: [ master ]jobs:  build:    name: Build工作    runs-on: self-hosted # 使用自己的服务器    steps:      - name: 读取仓库内容        uses: actions/checkout@v4      - name: 设置Java环境        run: |          pwd          java --version          mvn --version      - name: 编译打包        run: mvn package -Dmaven.test.skip=true      - name: 构建Docker镜像        run: |          docker build -f Dockerfile -t {{project-name}}:latest .      - name: 部署到服务器        run: |          docker rm -f {{project-name}          docker run -d --name {{project-name}} -p 1002:8080 {{project-name}}:latest          docker ps\n\n端口记得按需修改\n开始自动化部署将代码提交到GitHub后，在GitHub的Actions就能发现正在自动化部署。\n参考\n使用Github Actions + Docker 部署Spring Boot应用 - 掘金\nGithub Actions实现Spring Boot自动化部署（第二弹）_JavaGPT的技术博客_51CTO博客\n\n","tags":["Docker","GitHub"]},{"title":"Spring：IoC&DI 控制反转和依赖注入","url":"/2024/01/30/Spring%EF%BC%9AIoC-DI-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","content":"高内聚，低耦合软件开发需要遵循高内聚、低耦合的原则。\n\n高内聚指的是：一个模块中内部的各个元素之间的联系紧密程度高。\n低耦合指的是：软件中各个模块间的依赖关系越低越好。\n\n经典的MVC三层架构将程序分为了三层：\n\n数据访问层 DAO层：负责与数据库进行交互\n业务逻辑层 Service层：负责处理业务逻辑\n请求处理层 Controller层：负责接收请求、响应数据。\n\n在这种架构下，一个类只负责一个功能，在一定程度上提高了内聚、降低了耦合。\n但是传统开发过程中，我们需要在类的内部主动创建依赖对象，例如在三层架构中，Service层中需要创建Dao层的对象，Controller层需要创建Service层对象。\n这样导致了类与类之间的耦合，难以测试，IoC （Inversion of Control, 控制反转)这种设计思想就是为了降低这种耦合性。\nInversion of ControlIoC是一种设计思想，将创建和查找依赖对象的控制权交给容器，由容器进行管理。\n","tags":["java","Spring"]},{"title":"Hello World","url":"/2023/08/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["Hexo"]}]