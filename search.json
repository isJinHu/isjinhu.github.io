[{"title":"Docker + Nginx部署前端项目","url":"/2024/05/10/Docker-Nginx%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/","content":"后端部署可以查看：GitHub Actions &amp; Docker实现自动化部署 | Jin’s Blog (isjinhu.github.io)\n\n\nDocker + Nginx部署前端项目此处省略Docker安装步骤。\nsudo docker run --rm hello-world # 使用该命令可以测试docker是否安装成功\n\nStep 1: 拉取Nginx镜像docker pull nginx # 拉取镜像，没有指定版本会默认下载最新 \n\nStep 2: 创建挂载目录# 注意当前路径切换mkdir -p nginx/htmlmkdir -p nginx/logsmkdir -p nginx/confcd nginxchomd 777 html logs conf\n\nStep 3: 启动一个不挂载的容器docker run -d --name nginx -p 1000:80 nginx\n\n\n--name nginx：指定容器名称\n-p 1000:80 映射端口（宿主机:容器）\n这里可以自选端口，使用lsof -i:1000查看端口是否被占用\n\n\n-d 守护进程运行\n\nStep 4: 拷贝容器内默认配置docker cp nginx:/etc/nginx/nginx.conf nginx/conf/nginx.confdocker cp nginx:/etc/nginx/conf.d nginx/conf/conf.ddocker cp nginx:/usr/share/nginx/html nginx/\n\nStep 5: 停止、删除容器docker stop nginx # 停止容器docker rm nginx # 删除容器docker ps -a # 查看所有容器\n\nStep 6: 部署前端项目\n将前端项目目录（vue项目build后的dist目录）上传至nginx/html目录下，并修改nginx/conf.d/default.conf文件。\n\n内容可以参考，其中proxy_pass记得修改为对应部署的后端地址，listen为前端的端口。\n  server {    listen 1001;    location / {        root /usr/share/nginx/html/hmdp;    }    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   /usr/share/nginx/html;    }    location /api {        default_type  application/json;        #internal;        keepalive_timeout   30s;        keepalive_requests  1000;        #支持keep-alive        proxy_http_version 1.1;        rewrite /api(/.*) $1 break;        proxy_pass_request_headers on;        #more_clear_input_headers Accept-Encoding;        proxy_next_upstream error timeout;        proxy_pass http://127.0.0.1:8081;        # proxy_pass http://backend;    }}# upstream backend {#     server 127.0.0.1:80 max_fails=5 fail_timeout=10s weight=1;#     server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;# }\n\nStep 7: 运行镜像，其中-p指定对应的端口映射。docker run \\                  -p 1000:80 \\-p 1001:1001 \\--name nginx \\-v /home/ubuntu/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /home/ubuntu/nginx/conf/conf.d:/etc/nginx/conf.d \\-v /home/ubuntu/nginx/logs:/var/log/nginx \\-v /home/ubuntu/nginx/html:/usr/share/nginx/html \\-d nginx:latest\n\n","categories":["Docker"],"tags":["Docker"]},{"title":"GitHub Actions & Docker实现自动化部署","url":"/2024/05/10/GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","content":"关于使用GitHub Actions 和 Docker部署SpringBoot后端项目。\n\n\nGitHub Actions + Docker实现自动化部署可以先看一下这个教程：GitHub Actions工作流自动化的入门核心_哔哩哔哩_bilibili\nSpringBoot多环境切换\n参考: 31 SpringBoot多环境的切换(生产环境、开发环境、测试环境)_spring boot生产和开发环境-CSDN博客\n\nStep 1: 在resources/下创建application-dev.yaml和application-prouct.yaml文件，分别表示开发环境和生产环境。\nStep 2: 在两份配置文件中分别自定义配置，例如：\n\n\nStep 3: 在application.yaml文件中引用：\n\n\nStep 4: 激活配置文件：\n\n配置文件：在配置文件中指定spring.profiles.active=dev\n虚拟机参数：在VM options指定 -Dspring.profiles.active=dev\n命令行参数：java -jar xxx.jar –spring.profiles.active=dev\n\nIDEA中使用第二种即可，部署时使用命令行参数指定。\nDockerfile文件编写在项目根目录下，新建Dockerfile，内容如下：\nFROM fabric8/java-alpine-openjdk11-jreENV TZ=Asia/ShanghaiRUN rm -f /etc/localtime \\&amp;&amp; ln -sv /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \\&amp;&amp; echo \"Asia/Shanghai\" &gt; /etc/timezoneCOPY target/*.jar /app.jarENTRYPOINT [\"java\",\"-jar\",\"/app.jar\", \"--spring.profiles.active=product\"]\n\n注意：最后一行指定了配置文件。\nworkflow文件编写以下两种方式二选一即可。\n使用GitHub提供的Ubuntu环境在项目根目录下，新建./github/workflows/delpoy.yml文件，内容如下：\n# 使用Github Actions自动部署Spring Boot项目到服务器name: Deploy With Dockeron:  push:    branches: [ master ]jobs:  build:    name: Build工作    runs-on: ubuntu-latest # 使用GitHub提供的Ubuntu环境    steps:      - name: 读取仓库内容        uses: actions/checkout@v4      - name: 设置Java环境        uses: actions/setup-java@v4        with:          java-version: 11          distribution: 'adopt'          cache: 'maven'      #      - name: 缓存Maven依赖      #        uses: actions/cache@v3      #        with:      #          path: ~/.m2/repository      #          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}      #          restore-keys: |      #            ${{ runner.os }}-maven-      - name: 编译打包        run: mvn package -Dmaven.test.skip=true      - name: 登录到DockerHub        uses: docker/login-action@v3        with:          username: ${{ secrets.DOCKER_USERNAME }}          password: ${{ secrets.DOCKER_PASSWORD }}      - name: 构建Docker镜像        uses: docker/build-push-action@v5        with:          context: .          file: ./Dockerfile          push: true          tags: ${{ secrets.DOCKER_USERNAME }}/project-name:latest      - name: 部署到服务器        uses: appleboy/ssh-action@master        with:          host: ${{ secrets.SERVER_HOST }}          username: ${{ secrets.SERVER_USERNAME }}          port: ${{ secrets.SERVER_PORT }}          password: ${{ secrets.SERVER_PASSWORD }}          script: |            sh /path/to/delpoy.sh\n\nproject-name记得替换为自己的项目名称\n其中deploy.sh脚本内容如下（记得替换{{}}中内容，端口记得按需修改）：\ndocker pull {{username}}/{{project-name}}:latestdocker tag docker.io/{{username}}/{[project-name]}:latest {{project-name}}:latestdocker rm -f {{project-name}}docker run --name {{project-name}} -p 1002:8081 -d {{project-name}}:latestdocker image prune -af\n\nDockerHub记得先注册账号。如果Dockerhub上传的是私密镜像，记得在服务器登录账号：docker login\n在GitHub项目设置中添加yml文件中的secrets，位置如下：\n\n\n使用自己的服务器Step 1: 添加Runner\n\n\nStep 2: 选择服务器对应系统，按照所示步骤在服务器上执行即可：\n\n\n\n其中，运行config.sh脚本记得使用非root用户，否则会报错。\n其次./run.sh命令改为nohup ./run.sh &amp;在后台不挂断运行。\n\nStep 3: 在服务器记得安装maven和Java\nsudo apt updatesudo apt install mavenmvn --version # 验证是否安装成功\n\n\n参考：如何在 Ubuntu 20.04 上安装 Apache Maven-腾讯云开发者社区-腾讯云\n\nStep 4: 在项目创建workflow文件，内容如下：\nname: Deploy With Runneron:  push:    branches: [ master ]jobs:  build:    name: Build工作    runs-on: self-hosted # 使用自己的服务器    steps:      - name: 读取仓库内容        uses: actions/checkout@v4      - name: 设置Java环境        run: |          pwd          java --version          mvn --version      - name: 编译打包        run: mvn package -Dmaven.test.skip=true      - name: 构建Docker镜像        run: |          docker build -f Dockerfile -t {{project-name}}:latest .      - name: 部署到服务器        run: |          docker rm -f {{project-name}          docker run -d --name {{project-name}} -p 1002:8080 {{project-name}}:latest          docker ps\n\n端口记得按需修改\n开始自动化部署将代码提交到GitHub后，在GitHub的Actions就能发现正在自动化部署。\n参考\n使用Github Actions + Docker 部署Spring Boot应用 - 掘金\nGithub Actions实现Spring Boot自动化部署（第二弹）_JavaGPT的技术博客_51CTO博客\n\n","tags":["Docker","GitHub"]},{"title":"GitHub Pages & Hexo 搭建博客","url":"/2023/08/28/GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","content":"关于如何使用GitHub Pages和Hexo搭建个人博客并进行写作（使用Keep主题）。\n\n\nGitHub Pages &amp; Hexo 搭建博客Hexo 安装与配置\nHexo 安装与配置 | Easy Hexo 👨‍💻\n\n\n确认本地已经安装 Git 和 Node.js\n\n安装hexo: npm install -g hexo-cli\n\nTips：如果是mac需要使用sudo，一直卡顿可以尝试设置镜像，或者安装cnpm\nsudo npm install -g hexo-cli// 设置镜像npm config set registry=https://registry.npmmirror.com// 安装cnpmsudo npm install -g cnpmsudo cnpm install -g hexo-cli // 使用cnpm重新安装\n\n在本地创建一个文件夹，然后往这个文件夹中安装Hexo\n\n配置 Hexo，其配置文件为_config.yml：配置 Hexo | Easy Hexo 👨‍💻\n\n\nnpm install -g hexo-cli # 安装Hexomkdir mkdir &lt;your_blog_name&gt;  # 建立你的网站根目录，名字可以自己修改hexo init &lt;your_blog_name&gt; # 往这个文件夹中安装Hexo\n\n使用GitHub Pages部署到GitHub\n部署 Hexo | Easy Hexo 👨‍💻\n\nStep 1: 创建一个仓库：&lt;username&gt;.github.io\nStep 2: 在（&lt;username&gt;.github.io）安装部署插件\nnpm install hexo-deployer-git --savenpm install hexo-server --save\n\nStep 3: 部署到 GitHub\nhexo clean &amp;&amp; hexo d -g\n\nGitHub保存博客项目的源代码# 本地博客项目根目录下运行git initgit checkout -b hexo # 切换分支git add .git commit -m \"init\"git remote add origin git@github.com:isJinHu/isjinhu.github.io.git # 添加远程仓库git remote -vgit push origin hexo:hexo # push到远程仓库的hexo分支\n\nKeep主题安装与配置\nhome_article | Keep 主题使用手册 &amp;&amp; XPoet's Blog\n\nStep 1: 安装Keep主题\ncd &lt;your_blog_name&gt;npm install hexo-theme-keep\n\nStep 2: 使用Keep主题：在 Hexo 配置文件 _config.yml 中将 theme 设置为 keep。\ntheme: keep\n\nStep 3：配置Keep主题：在文件夹下创建一个 _config.keep.yml文件，参照文档进行配置：base_info | Keep 主题使用指南\n其他：\n\n可能用到的命令：\nnpm install hexo-theme-keep # 安装 keep 主题npm install hexo-filter-mathjax # 安装显示数学公式的插件npm install hexo-generator-searchdb # 安装站内搜索插件npm install hexo-wordcount # 安装统计字数插件hexo new page about # hexo创建页面命令，使用该命令创建about页面。\n数学公式 | Keep 主题使用指南：建议开启。\n\n配置时的图标文件可以放在 source/images文件夹中。\n\nGitalk设置：comment | Keep 主题使用指南\n\n\n默认博客模板在 scaffolds/post.md中可以设置默认模板，比如默认打开公式渲染等。\ntitle: {{ title }}date: {{ date }}mathjax: truetags:\n\n图片插入：结合TyporaStep 1：修改 _config.yml文件\npost_asset_folder: true # 将这个配置项改为true，这样hexo new “postname\"时会创建一个同名文件夹marked:  prependRoot: true  postAsset: true\n\nStep 2：安装插件\nnpm install hexo-asset-img --savenpm install hexo-renderer-marked --save\n\nStep 3: 设置Typora插入图片时路径：${filename}\nHexo deploy失败？\n执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054_copying files from extend dirs…warning: in the w_Candle_light的博客-CSDN博客\n\nhexo config deploy.repository git@github.com:isjinhu/isjinhu.github.io.git\n\n其他链接Hexo 如何隐藏文章 - yangstar - 博客园\n","tags":["GitHub","Hexo"]},{"title":"Java函数式编程","url":"/2024/10/02/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","content":"函数式编程是一种“编程范式”，以函数为基本构建单元。在这种范式中，函数可以作为参数传递给其他函数、作为返回值返回，或赋值给变量。\n\n由于Java不支持单独定义函数，我们可以将静态方法视为独立的函数，将实例方法视为自带this参数的函数。（from 函数式编程 - Java教程 - 廖雪峰的官方网站）\n\nJava8引入了对函数式编程的支持，主要包括以下几个方面：\n\n函数式接口：允许在方法中传递行为。\nLambda表达式：允许用简洁的方式来表示函数，简化了匿名内部类的写法。\nStream API：支持对集合进行函数式操作，如过滤、映射、聚合等，并且支持使用并行流提高性能。\nOptional：用于处理可能为null的值，避免NullPointerException。\n\n\n\n函数式接口函数式接口是仅包含一个方法的接口，只提供一个功能，通过这些接口我们可以实现行为在方法间的传递。比如Runnable、Comparable、Callable都可以视为函数式接口。\nJava 8引入了java.util.function包，包含多个常用的函数式接口：Function&lt;T,R&gt;、Consumer&lt;T&gt;、Supplier&lt;T&gt;，Predicate&lt;T&gt;、UnaryOperator&lt;T&gt;、BinaryOperator&lt;T&gt;，并且在Java 8之后可以用lambda表达式来进行实例化。\npublic class LambdaTest {    public static void main(String[] args) {        // 1. Function&lt;T, R&gt; 接收一个T类型的参数，返回一个R类型的结果        Function&lt;Integer, String&gt; intToString= Objects::toString;        System.out.println(intToString.apply(123));        // 2. Consumer&lt;T&gt; 接收一个T类型的参数，不返回结果，通常用于执行某些操作        Consumer&lt;String&gt; print = System.out::println;        print.accept(\"Hello, World!\");        // 3. BiConsumer&lt;T, U&gt; 接收两个参数，不返回结果        BiConsumer&lt;String, String&gt; concat = (a, b) -&gt; System.out.println(a + b);        concat.accept(\"Hello, \", \"World!\");        // 4. Supplier&lt;T&gt; 不接收参数，返回一个T类型的结果        Supplier&lt;Double&gt; random = Math::random;        System.out.println(random.get());        // 5. Predicate&lt;T&gt; 接收一个T类型的参数，返回一个boolean类型的结果        Predicate&lt;Integer&gt; isEven = i -&gt; i % 2 == 0;        System.out.println(isEven.test(2));        // 6. BiPredicate&lt;T, U&gt; 接收两个参数，返回一个boolean类型的结果        BiPredicate&lt;Integer, Integer&gt; isGreater = (a, b) -&gt; a &gt; b;        System.out.println(isGreater.test(2, 1));        // 7. UnaryOperator&lt;T&gt; 接收一个T类型的参数，返回一个T类型的结果        UnaryOperator&lt;Integer&gt; square = i -&gt; i * i;        System.out.println(square.apply(3));        // 8. BinaryOperator&lt;T&gt; 接收两个T类型的参数，返回一个T类型的结果        BinaryOperator&lt;Integer&gt; add = (a, b) -&gt; a + b;        System.out.println(add.apply(1, 2));    }}\n\nLambda表达式Lambda表达式是Java 8引入的一种语法，用于简化函数式编程中匿名内部类的使用。\n// 匿名内部类写法Runnable r=new Runnable() {    @Override    public void run() {        System.out.println(\"Hello, World!\");    }};// Lambda写法r=()-&gt;System.out.println(\"Hello, World!\");\n\n除此之外，还提供了方法引用，可以进一步简化对现有方法的引用。\nFunction&lt;Double, Double&gt; sqrt = Math::sqrt; // 静态方法引用String str = \"Hello, World!\";Supplier&lt;Integer&gt; stringLength = str::length; // 实例方法引用BiPredicate&lt;String, String&gt; equals = String::equals;Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::new;\n\nStream APIStream API支持对集合进行函数式操作，如过滤、映射、聚合等，并且支持使用并行流提高性能。\n一般包括三步：创建流、中间操作、终止操作。\nclass StreamTest {    public static void main(String[] args) {        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};        List&lt;Integer&gt; list = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);        // 1. 创建流        // 1.1 通过集合创建流        List&lt;Integer&gt; collect = list.stream().map(i -&gt; i * i).collect(Collectors.toList());        // list.stream().map(i -&gt; i * i).toList(); toArray();        // 1.2 通过数组创建流        Arrays.stream(arr)              .filter(i -&gt; i % 2 == 0)              .min()              .ifPresentOrElse(System.out::println, () -&gt; System.out.println(\"No even number\"));        // 1.3 通过Stream.of()创建流        long count = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).count();        System.out.println(count);        // 1.4 创建无限流        Stream.generate(Math::random).limit(10).forEach(System.out::println);        // 2. 中间操作：filter, map, limit, skip, distinct, sorted, peek        List&lt;Integer&gt; collect1 = Stream.of(3, 8, 10, 6, 2, 7, 1, 9, 4, 5).filter(i -&gt; i % 2 == 0) // 条件过滤                                       .map(i -&gt; i * i) // 映射操作                                       .limit(3) // 限制数量                                       .skip(1) // 跳过                                       .distinct() // 去重                                       .sorted() // 排序                                       .peek(System.out::println) // 调试：需要注意peek参数是Consumer类型，没有返回值                                       .toList();        // 3. 终止操作：forEach, count, collect, reduce, min, max, findFirst, findAny, anyMatch, allMatch, noneMatch        list.stream().forEach(System.out::println);        long count1 = list.stream().count();        List&lt;Integer&gt; collect2 = list.stream().collect(Collectors.toList());        int sum = list.stream().reduce(0, Integer::sum); // reduce()接收一个初始值和一个BinaryOperator，返回一个结果        int min = list.stream().min(Integer::compareTo).orElse(-1);        int max = list.stream().max(Integer::compareTo).orElse(-1);        int first = list.stream().findFirst().orElse(-1); // findFirst()返回第一个元素        int any = list.stream().findAny().orElse(-1); // findAny()返回任意一个元素        boolean anyMatch = list.stream().anyMatch(i -&gt; i % 2 == 0); // anyMatch()判断是否有一个元素满足条件        boolean allMatch = list.stream().allMatch(i -&gt; i % 2 == 0); // allMatch()判断是否所有元素满足条件        boolean noneMatch = list.stream().noneMatch(i -&gt; i % 2 == 0); // noneMatch()判断是否所有元素都不满足条件    }}\n\n区分map、reduce、collect\nmap是一个中间操作，用于将流中的每个元素应用给定的函数，转换为另一种类型或形式，返回流。\nreduce是一个终止操作，用于将流中的所有元素聚合成一个单一的值，通常用于计算总和、乘积等，返回Optional。\ncollect是一个终止操作，用于将流中的元素收集到一个集合、字符串或其他形式的结果，通常用于转换流为可用的数据结构。\n\nOptional在Stream的部分终止操作会返回Optional，比如max\\min\\findFirst\\findAny\nclass OptionalTest{    public static void main(String[] args) {        // 1. 创建Optional对象        Optional&lt;String&gt; optional = Optional.of(\"Hello, World!\");        Optional&lt;String&gt; empty = Optional.empty();        Optional&lt;String&gt; nullable = Optional.ofNullable(null);        // 2. 判断是否有值        System.out.println(optional.isPresent());        System.out.println(empty.isEmpty());        // 3. 获取值        System.out.println(optional.get());        System.out.println(empty.orElse(\"No value\"));        System.out.println(nullable.orElseGet(() -&gt; \"No value\"));        // 4. 转换        Optional&lt;Integer&gt; length = optional.map(String::length);        Optional&lt;String&gt; upper = optional.flatMap(s -&gt; Optional.of(s.toUpperCase()));        // 5. 过滤        Optional&lt;String&gt; filter = optional.filter(s -&gt; s.length() &gt; 5);        // 6. 如果有值则执行        optional.ifPresent(System.out::println);        // 7. 如果有值则执行，否则执行        optional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(\"No value\"));    }}\n","tags":["Java"]},{"title":"Java多线程:AQS&线程池","url":"/2024/09/29/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-AQS-%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"\n\nReetrantLock实现了Lock接口\n\nlock() 加锁\nlockInterruptibly() 响应中断的加锁\ntryLock() 尝试获取锁，非阻塞的获取锁\nunlock() 解锁\n\nlock：snyc.lock\nsync是Sync抽象内部类，是AQS的子类，又有NonFairSync和FairSync两个子类，分别是非公平锁和公平锁，ReentrantLock默认是非公平锁。这些子类基于AQS的模板方法实现了具体的加锁和解锁操作。\nAQS：AbstractQueuedSynchronizer\n模板方法设计模式：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\nAQS\nvolatile int state：代表同步状态，不同子类实现不同的含义，如ReentrantLock中表示重入次数，Semaphore中表示可用许可数。\nfinal int getState()：获取同步状态\nfinal void setState(int newState)：设置同步状态\nfinal boolean compareAndSetState(int expect, int update)：CAS设置同步状态\nCAS: Compare And Swap，是一种无锁算法，通过比较内存中的值和期望值，如果相等则更新内存中的值，否则不更新。包括三个操作数：内存值V、旧的预期值A、要修改的新值B。\n\n\n\n\nNode：双向链表，用于保存等待线程，每个Node包含一个Thread引用，一个waitStatus状态，一个prev前驱节点，一个next后继节点。\n一个线程是否可以获取锁，取决于state，获取不到则进入等待队列，等待队列是一个双向链表，每个节点代表一个等待线程。\n\n\n\n"},{"title":"LeetCode刷题笔记: 回溯&贪心&动态规划","url":"/2024/05/14/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E5%9B%9E%E6%BA%AF-%E8%B4%AA%E5%BF%83-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"回溯就是暴力穷举，是一种搜索方式，其核心思想是从一个初始状态出发，深度优先搜索遍历所有可能的解决方案（解空间），如果确定某种方案不可行就回溯到上一步重新搜索。一般用来解决组合问题（无序）、子集问题（无序）、排列问题（有序）、字符串切割问题、棋盘问题等。\n贪心算法的思想是在每个决策阶段，选择局部最优解，以此获取全局最优解。\n动态规划\n\n\n回溯回溯就是暴力穷举，其核心思想是从一个初始状态出发，深度优先搜索遍历所有可能的解决方案（解空间），当遇到正解就记录，直到找到解或者尝试所有可能后终止。\n可以解决：\n\n组合问题：n个数取满足规则的k个数\n子集问题：n个数有多少符合条件的子集\n排列问题：n个数按一定规则的全排列有几种方式\n字符串分割问题：字符串按一定规则有几种切割方式\n棋盘问题：N皇后、数独等\n\n一般需要考虑3个问题：\n\n路径：已经做出的选择\n选择列表：可以做的选择\n结束条件：无法再做选择的条件\n\nresult = []def backtrack(path, choices):    if 满足结束条件:        result.add(path)        return    for choice in choices:        记录选择        backtrack(path, choices)        撤销选择\n\n\n回溯算法解题套路框架 | labuladong 的算法笔记\n代码随想录\n\n组合问题77. 组合 - 中等77. 组合 - 力扣（LeetCode）\n思路：\n46. 全排列 - 中等46. 全排列\n思路：这题是回溯的经典应用。按我们自己穷举全排列的思路，首先选择第一个的数字，下一个的数字在剩下的数字列表中选择，这样直到所有的数字都选完。所以我们需要记录之前已经选过的数字，从没选过的数字中进行当前阶段的选择。\n具体来说，我们可以从第0个位置开始，递归选择每个没被选过的数字，选择完所有元素就回溯撤销选择。\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; res;    List&lt;Integer&gt; path;    int[] nums;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {        this.res=new ArrayList&lt;&gt;();        this.path=new ArrayList&lt;&gt;(nums.length);        this.nums=nums;        dfs(0, new boolean[nums.length]);        return res;    }    private void dfs(int i, boolean[] used){        if(nums.length==i){            res.add(new ArrayList&lt;&gt;(path));            return;        }        for(int j=0;j&lt;nums.length;j++){            if(!used[j]){                path.add(nums[j]); // 选择                used[j]=true;                dfs(i+1, used); // 递归                path.remove(i); // 撤销选择                used[j]=false;            }        }    }}\n\n78. 子集 - 中等78. 子集\n思路：对于每个数字我们可以选或者不选，因此第i层就是对会有对第i个数字选或者不选两个选项。\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; res;    List&lt;Integer&gt; path;    int[] nums;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {        this.res=new ArrayList&lt;&gt;();        this.path=new ArrayList&lt;&gt;();        this.nums=nums;        dfs(0);        return res;    }    private void dfs(int i){        if(i==nums.length){            res.add(new ArrayList&lt;&gt;(path));            return;        }        // 选这个数字        path.add(nums[i]);        dfs(i+1);\t\t// 不选这个数字        path.remove(path.size()-1);         dfs(i+1);        // 撤销选择：需要注意这里的撤销选择只的是对这个数字的选择行为本身（回到的是选择上一个数字的状态），而不是选这个数字    }}\n\n39. 组合总和 - 中等39. 组合总和\n思路：对于每个节点，我们都可以\n贪心45. 跳跃游戏 II - 力扣（LeetCode）","tags":["LeetCode","算法"]},{"title":"LeetCode刷题笔记:图论相关","url":"/2024/09/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3/","content":"Floyd算法可以求任意两点之间的最短距离（多源最短路径），核心思想是将每个点作为中间点去更新最短路径。\nDijkstra算法可以求一个点到其他点之间的最短距离（单源最短路径）。\n\n\nFloyd算法基于动态规划思想，一共n个点的图，a到b的最短路径，可以基于n-1个点的图计算。记f[k][i][j]为从i到j的最短路径，且中间节点编号都&lt;=k比较是否经过点时的路径长度核心代码：\nfor(int k=0;k&lt;n;k++){    for(int i=0;i&lt;n;i++){        for(int j=0;j&lt;n;j++){            // 可以经过中间点k时，最短路径是否可以更新            f[i][j]=Math.min(f[i][j], f[i][k]+f[k][j]);        }    }}\n\n1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）-中等class Solution {    public int findTheCity(int n, int[][] edges, int distanceThreshold) {        int[][] floyd=new int[n][n];        for(int i=0;i&lt;n;i++){            Arrays.fill(floyd[i], -1);             floyd[i][i]=0;        }        for(int[] e:edges){            int x=e[0], y=e[1], weight=e[2];            floyd[x][y]=floyd[y][x]=weight;        }        for(int k=0;k&lt;n;k++){            for(int i=0;i&lt;n;i++){                for(int j=0;j&lt;n;j++){                    if(floyd[i][k]&gt;=0&amp;&amp;floyd[k][j]&gt;=0){                        // 这里一定要记得判断                        if(floyd[i][j]==-1){                            floyd[i][j]=floyd[i][k]+floyd[k][j];                        }else{                            floyd[i][j]=Math.min(floyd[i][j], floyd[i][k]+floyd[k][j]);                        }                                            }                }            }        }        int res=0, minCnt=n+1;        for(int i=0;i&lt;n;i++){            int cnt=0;            for(int j=0;j&lt;n;j++){                if(floyd[i][j]&gt;=0&amp;&amp;floyd[i][j]&lt;=distanceThreshold){                    cnt++;                }            }            if(cnt&lt;=minCnt){                minCnt=cnt;                res=i;            }        }        return res;    }}\n\n一般我们会将无法到达设为INF，但是需要注意JAVA中INF+INF会溢出，所以可以设置为Integer.MAX_VALUE/2避免溢出，减少检查，参见：灵茶山艾府。\n其他题目2642. 设计可以求最短路径的图类 - 力扣（LeetCode）\n\n初始化时时间复杂度为\n增加边时间复杂度为：只需要更新经过这个点的所有情况\n获取最短路径：，\n空间复杂度：\n\n2976. 转换字符串的最小成本 I - 力扣（LeetCode）\n\n计算的最短路径，然后遍历字符串计算更新代价即可。\n\n2959. 关闭分部的可行集合数目 - 力扣（LeetCode）\n\n循环将\n\n","tags":["LeetCode","算法"]},{"title":"LeetCode刷题笔记：数组&双指针","url":"/2024/05/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/","content":"\n\n双指针双指针算法是一类用2个指针遍历数组或链表的算法，通常用来解决在数据中进行搜索、排序、匹配的问题。\n同向双指针同向双指针也可叫快慢双指针，一般慢指针每次移动一步，快指针则移动两步或更多步。\n一般用来解决链表问题。\n用在数组中，可以解决有序数组要根据一定条件原地创建新数组这样一类问题。具体来说，快指针指向旧数组当前遍历位置，慢指针指向新数组长度（下一个元素要放置的位置），根据新旧数组判断快指针指向的元素是否可以加入新数组，如88. 合并两个有序数组、27. 移除元素、26. 删除有序数组中的重复项、80. 删除有序数组中的重复项 II 。\n88. 合并两个有序数组88. 合并两个有序数组\n\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n\n从两个数组末尾遍历，慢指针指向下一个元素将要放置的位置，2个快指针分别指向2个数组当前正在对比的元素，哪个数字更大就放置在慢指针指向位置，然后再移动指针。\nclass Solution {    public void merge(int[] nums1, int m, int[] nums2, int n) {        // 同向双指针        int slow=m+n-1;        int fast1=m-1, fast2=n-1;        while(fast1&gt;=0&amp;&amp;fast2&gt;=0){            if(nums1[fast1]&gt;nums2[fast2]){                nums1[slow--]=nums1[fast1--];            }else{                nums1[slow--]=nums2[fast2--];            }        }        while(fast2&gt;=0){            nums1[slow--]=nums2[fast2--];        }    }}\n\n27. 移除元素27. 移除元素\n\n输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2,,]解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）\n\n慢指针指向下一个元素将要放置的位置，快指针指向当前遍历位置，如果这个数是要移除的元素，快指针后移，否则将其复制到慢指针指向位置再后移。\nclass Solution {    public int removeElement(int[] nums, int val) {        // 同向双指针        int slow=0, fast=0;        while(fast&lt;nums.length){            if(nums[fast]!=val){                nums[slow++]=nums[fast];            }            fast++;        }        return slow;    }}\n\n26. 删除有序数组中的重复项26. 删除有序数组中的重复项\n\n输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n慢指针指向下一个元素将要放置的位置（相当于新数组长度位置），快指针指向当前遍历位置。\n如果快指针指向的元素已经在新数组中slow-1位置出现，那么就重复，快指针直接后移，否则复制到慢指针位置再后移。\nclass Solution {    public int removeDuplicates(int[] nums) {        // 同向双指针        if(nums.length==1) return 1;        int slow=1, fast=1;        while(fast&lt;nums.length){            if(nums[fast]==nums[slow-1]){                fast++;            }else{                nums[slow++]=nums[fast++];            }        }        return slow;    }}\n\n80. 删除有序数组中的重复项 II80. 删除有序数组中的重复项 II\n\n输入：nums = [1,1,1,2,2,3]输出：5, nums = [1,1,2,2,3]解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素\n\n慢指针指向下一个元素将要放置的位置（相当于新数组长度位置），快指针指向当前遍历位置。\n如果当前元素与新数组的倒数第二个数一样，说明新数组已出现2次该数，该数不需要加入新数组，快指针直接后移，否则复制后再后移。\nclass Solution {    public int removeDuplicates(int[] nums) {        if(nums.length&lt;3) return nums.length;        int slow=2, fast=2;        while(fast&lt;nums.length){            if(nums[slow-2]!=nums[fast]){                nums[slow++]=nums[fast++];            }else{                fast++;            }        }        return slow;    }}\n\n数组169. 多数元素-摩尔投票169. 多数元素 - 力扣（LeetCode）\n寻找长度为n的数组中出现次数大于 ⌊ n/2 ⌋ 的多数元素。\n\n输入：nums = [3,2,3]输出：3\n\n摩尔投票\n\n记多数元素的票为1，其他为-1，那么所有数字的票数和一定&gt;0\n若前a个数字票数和=0，那么剩余的n-a个数字的票数和一定&gt;0，多数元素依旧不变。\n\n因此，票数和=0时，可以缩小剩余数组区间。假设首个元素n为多数元素x，那么当n=x时，抵消的元素中一半是多数元素x；当n!=x时，抵消的多数元素可能是0-一半。因此最后一轮假设的必定是多数元素。\n\n多数元素为t个，t&gt;n/2，2(n-t)&lt;n，因此抵消到最后剩余的必定是多数元素为首的数组。\n\nclass Solution {    public int majorityElement(int[] nums) {        int x=0, votes=0;        for(int n:nums){            if(votes==0) x=n;            votes += n == x ? 1 : -1;        }        return x;    }}\n\n189. 轮转数组 #todo 旋转平移类189. 轮转数组 - 力扣（LeetCode）\n首先反转整个数组，然后反转前k个，反转后n-k个，就是轮转后的数组。\n注意：k=k%n。\nclass Solution {    public void rotate(int[] nums, int k) {        int n=nums.length;        k=k%n;        if(k==0) return;        reverse(nums, 0, nums.length-1);        reverse(nums, 0, k-1);        reverse(nums, k, nums.length-1);    }    private void reverse(int[] nums, int start, int end){        while(start&lt;end){            int tmp=nums[start];            nums[start++]=nums[end];            nums[end--]=tmp;        }    }}\n\n121. 买卖股票的最佳时机121. 买卖股票的最佳时机 - 力扣（LeetCode）\n只能在某天买入，未来某天卖出。\n\n输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\n思路：只要知道这天之前最低是多少，就是当日最大利润，因此遍历时记录min以及当前利润，更新最大利润即可。\nclass Solution {    public int maxProfit(int[] prices) {        int minPrice=prices[0];        int res=0;        for(int i=1;i&lt;prices.length;i++){            res=Math.max(res, prices[i]-minPrice);            minPrice=Math.min(minPrice, prices[i]);        }        return res;    }}\n\n122. 买卖股票的最佳时机 II - 力扣（LeetCode）在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n\n输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。     总利润为 4 + 3 = 7 。\n\n思路：只要比前一天高，就买入，第二天就卖出。\nclass Solution {    public int maxProfit(int[] prices) {        int res=0;        for(int i=1;i&lt;prices.length;i++){            if(prices[i]&gt;prices[i-1]){                res+=prices[i]-prices[i-1];            }        }        return res;    }}\n\n55. 跳跃游戏 - 力扣（LeetCode）- 动态规划给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。\n\n输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n思路：对于每个位置\n","tags":["LeetCode","算法"]},{"title":"LeetCode刷题笔记：栈&单调栈&单调队列","url":"/2024/05/11/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A0%88-%E5%8D%95%E8%B0%83%E6%A0%88-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","content":"栈是一种「先进后出」的数据结构。单调栈是一种特殊的栈，在满足「先进后出」规则基础上，同时满足「从栈底到栈顶的元素单调递增/减」，因此也分为单调递增栈，单调递减栈。\n单调栈用来解决下一个更大/小元素、上一个更大/小元素这一类的典型问题。比如739. 每日温度，84. 柱状图中最大的矩形，42. 接雨水都是这类问题。\n队列是一种「先进先出」的数据结构。单调队列是一种特殊的队列，在满足「先进先出」规则基础上，同时满足「从队首到队尾的元素单调递增/减」。\n单调队列用来解决滑动窗口内的最大/小值、中位数的动态查询这一类问题。比如239. 滑动窗口最大值。\n\n\n单调栈这里以单调递减栈为例，可以解决求下一个更大元素问题。\n单调递减栈的思想是：只有比栈顶元素小的元素才能直接进栈，否则需要将栈中更小的元素出栈。这样，当元素出栈时，就找到了下一个更大元素。\n739. 每日温度 - 中等739. 每日温度：给定一个表示每日温度的整数数组，求对于每天在第几天后温度会比这天更高，如果没有，填0。\n\n输入: temperatures = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n\n思路：求的是下一个更大元素的索引距离，用单调递减栈，栈中记录的实际上是还没算出「下一个更大元素」的数字下标。\n时间复杂度：O(n)，每个元素只进出栈一次。\nclass Solution {    public int[] dailyTemperatures(int[] temperatures) {        int length=temperatures.length;        int[] res=new int[length];        Deque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;(); // 单调栈        for(int i=0;i&lt;length;i++){            while(!stack.isEmpty()&amp;&amp;temperatures[i]&gt;temperatures[stack.peekLast()]){                int j=stack.pollLast();                res[j]=i-j;            }            stack.offerLast(i);        }        // while(!stack.isEmpty()){        //     res[stack.pollLast()]=0;        // }        return res;    }}\n\n84. 柱状图中最大的矩形 - 困难84. 柱状图中最大的矩形：给定柱状图中每个柱子高度，求能勾勒出的矩形最大面积。\n\n\n\n输入：heights = [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10\n\n思路1：想要以某个柱子为高，那么必须知道这个柱子左右侧更矮柱子的下标，即要求更小元素下标。因此用2个单调递增栈，分别求上/下一个更小元素并保存，最后在遍历求面积即可。\n思路2：计算右侧更矮柱子的下标时，单调栈用于维护没有找到右侧更矮柱子的柱子索引，当某个元素出栈时，说明这个元素找到右侧更矮柱子，同时新的栈顶元素（如果存在）一定是当前出栈柱子左侧更矮的柱子。（因为如果左侧有更高的柱子，都已经出栈，而更矮的柱子会留在里面）\nclass Solution {    public int largestRectangleArea(int[] heights) {        Deque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;();        int res=0;        for(int i=0;i&lt;heights.length;i++){            while(!stack.isEmpty()&amp;&amp;heights[i]&lt;heights[stack.peekLast()]){                int curHeight=heights[stack.pollLast()];                int leftIdx=0;                if(!stack.isEmpty()){                    leftIdx=stack.peekLast()+1;                }                int area=curHeight*(i-leftIdx);                res=Math.max(res,area);            }            stack.offerLast(i);        }        while(!stack.isEmpty()){            int curHeight=heights[stack.pollLast()];            int leftIdx=0;            if(!stack.isEmpty()){                leftIdx=stack.peekLast()+1;            }            int area=curHeight*(heights.length-leftIdx);            res=Math.max(res,area);        }        return res;    }}\n\n42. 接雨水 - 困难单调栈做法42. 接雨水\n\n\n思路：当我们找到右侧第一个比某个位置大的元素时，这里就能接水，相当于横着计算。\n\n\nclass Solution {    public int trap(int[] height) {        // 单调栈做法        Deque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;();        int res=0;        for(int i=0;i&lt;height.length;i++){            while(!stack.isEmpty()&amp;&amp;height[stack.peekLast()]&lt;=height[i]){                int curHeight=height[stack.pollLast()];                if(stack.isEmpty()) break;                int left=stack.peekLast();                int h=Math.min(height[left], height[i])-curHeight;                res+=h*(i-left-1);            }            stack.offerLast(i);        }        return res;    }}\n\n双指针做法思路：\n\n某个位置能接的水=min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。\n使用相向双指针遍历分别记录左右两侧当前最大值，其中较小的那个就是公式用到的那个。\n\n时间复杂度：O(n)，空间复杂度：O(1)。\nclass Solution {    public int trap(int[] height){        // 双指针做法: min{lMax, rMax}-h[i], lMax=max{0,...,i}        int res=0;        int left=0, right=height.length-1;        int lMax=height[0], rMax=height[right];        while(left&lt;=right){            if(lMax&lt;rMax){                lMax=Math.max(lMax, height[left]);                res+=lMax-height[left++];            }else{                rMax=Math.max(rMax, height[right]);                res+=rMax-height[right--];            }        }        return res;    }}\n\n单调队列单调队列的思想是：只有当一个元素是最值或者可能成为最值时才保留，否则出队。这样，每次移动窗口时，队首就是当前窗口最值。\n239. 滑动窗口最大值 - 困难239. 滑动窗口最大值\n\n\n思路：对于窗口[1 3 -1]，其中3是最大值，3之前的数字1比3小且更早离开，所以无论窗口如何移动都不会成为最大值，3之后的数字-1比3小但更晚离开，因此可能成为最大值。每次移动时，需要判断队首的最值是否离开窗口，判断队内的旧数字是否还可能成为新的最值，如果比新数字小就不可能，需要出队；否则可能，保留，然后再将新数字入队。\nclass Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        Deque&lt;Integer&gt; queue=new ArrayDeque&lt;&gt;();        int[] res=new int[nums.length-k+1];        // i指向即将入栈的元素，j指向即将出栈的元素        for(int i=0, j=-k+1;i&lt;nums.length;i++,j++){            // 加入新元素，让窗口大小保持为k            while(!queue.isEmpty()&amp;&amp;queue.peekLast()&lt;nums[i]){                queue.pollLast();            }            queue.offerLast(nums[i]); // 入队            if(j&lt;0) continue;            // 计算当前窗口最值            res[j]=queue.peekFirst();            // 移动窗口            if(queue.peekFirst()==nums[j]){                queue.pollFirst();            }        }        return res;    }}\n\n栈：394. 字符串解码394. 字符串解码\nclass Solution {    public String decodeString(String s) {        StringBuilder res=new StringBuilder();        int times = 0;        LinkedList&lt;Integer&gt; timesStack=new LinkedList&lt;&gt;();        LinkedList&lt;String&gt; substrStack=new LinkedList&lt;&gt;();        for(int i=0;i&lt;s.length();i++){            char c=s.charAt(i);            if(c&gt;='0'&amp;&amp;c&lt;='9'){                times=times*10+Integer.parseInt(c+\"\");            }else if(c == '['){                timesStack.add(times);                substrStack.add(res.toString());                times=0;                res=new StringBuilder();            }else if(c==']'){                int curTimes=timesStack.pollLast();                StringBuilder str=new StringBuilder();                while(curTimes--!=0) str.append(res);                res=new StringBuilder(substrStack.pollLast()+str);            }else{                res.append(c);            }        }        return res.toString();    }}\n\n","tags":["LeetCode","算法"]},{"title":"Hello World","url":"/2023/08/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["Hexo"]},{"title":"LeetCode刷题笔记：滑动窗口","url":"/2024/09/03/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","content":"滑动窗口算法的核心思想是通过两个指针来定义一个窗口，通过动态调整窗口大小和位置来求解问题。\n通常用于解决子数组、子串、子序列相关问题，比如：最大最小子数组（最大子数组和）、（包含所有字符的/无重复字符的）子字符串、定长子数组的最大/小值、滑动窗口平均值。\n\n\n滑动窗口子串3. 无重复字符的最长子串 - 中等3. 无重复字符的最长子串 - 力扣（LeetCode）\n给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。\nclass Solution {    public int lengthOfLongestSubstring(String s) {        int res=0;        int start=0, end=0; // 滑动窗口指针        Map&lt;Character, Integer&gt; lastOccuredMap=new HashMap&lt;&gt;(); // 记录字符出现位置+1,遇到重复窗口起点应移动到此处        while(end&lt;s.length()){            char c=s.charAt(end++); // 窗口扩大            if(lastOccuredMap.containsKey(c)){ // 是否需要缩小                start=Math.max(start, lastOccuredMap.get(c));            }            res=Math.max(res, end-start);            lastOccuredMap.put(c, end);        }        return res;    }}\n\n438. 找到字符串中所有字母异位词 -中等 （类似最小覆盖子串）438. 找到字符串中所有字母异位词 - 力扣（LeetCode）\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\nclass Solution {    public List&lt;Integer&gt; findAnagrams(String s, String p) {        List&lt;Integer&gt; res=new ArrayList&lt;&gt;();        if(s.length()&lt;p.length()) return res;        Map&lt;Character, Integer&gt; targetMap=new HashMap&lt;&gt;(); // 目标窗口        Map&lt;Character, Integer&gt; windowMap=new HashMap&lt;&gt;(); // 滑动窗口记录        for(char c:p.toCharArray()){            targetMap.put(c, targetMap.getOrDefault(c,0)+1);        }        int start=0, end=0; // 滑动窗口指针        int count=0;        while(end&lt;s.length()){            char cur=s.charAt(end++);            if(targetMap.containsKey(cur)){                windowMap.put(cur, windowMap.getOrDefault(cur, 0)+1);                if(windowMap.get(cur).equals(targetMap.get(cur))) count++; // 注意：这里是Integer，一定得用equals，而不是==            }            while(targetMap.size()==count){                if(end-start==p.length()){                    res.add(start);                }                char expired=s.charAt(start++);                if(targetMap.containsKey(expired)){                    if(targetMap.get(expired).equals(windowMap.get(expired))) count--;                    windowMap.put(expired, windowMap.get(expired)-1);                }            }        }        return res;    }}\n\n567. 字符串的排列 - 中等567. 字符串的排列 - 力扣（LeetCode）\nclass Solution {    public boolean checkInclusion(String s1, String s2) {        if(s1.length()&gt;s2.length()) return false;        Map&lt;Character, Integer&gt; targetMap=new HashMap&lt;&gt;(); // 目标窗口        Map&lt;Character, Integer&gt; windowMap=new HashMap&lt;&gt;(); // 滑动窗口记录        for(char c:s1.toCharArray()){            targetMap.put(c, targetMap.getOrDefault(c,0)+1);        }        int start=0, end=0; // 滑动窗口指针        int count=0;        while(end&lt;s2.length()){            char cur=s2.charAt(end++);            if(targetMap.containsKey(cur)){                windowMap.put(cur, windowMap.getOrDefault(cur, 0)+1);                if(windowMap.get(cur).equals(targetMap.get(cur))) count++; // 注意：这里是Integer，一定得用equals，而不是==                while(count==targetMap.size()){                    if(end-start==s1.length()){return true;}                    char expired=s2.charAt(start++);                    if(windowMap.get(expired).equals(targetMap.get(expired))) count--;                    windowMap.put(expired, windowMap.get(expired)-1);                }            }else{                windowMap=new HashMap&lt;&gt;();                count=0;                start=end;            }        }        return false;    }}\n\n76. 最小覆盖子串 - 困难76. 最小覆盖子串 - 力扣（LeetCode）\nclass Solution {    public String minWindow(String s, String t) {        if(s.length()&lt;t.length()) return \"\";        Map&lt;Character, Integer&gt; targetMap=new HashMap&lt;&gt;(); // 目标窗口        Map&lt;Character, Integer&gt; windowMap=new HashMap&lt;&gt;(); // 滑动窗口记录        for(char c:t.toCharArray()){            targetMap.put(c, targetMap.getOrDefault(c,0)+1);        }        int start=0, end=0; // 滑动窗口指针        int minLen=s.length()+1, minStart=0, minEnd=0;        int count=0;        while(end&lt;s.length()){            char cur=s.charAt(end++);            if(targetMap.containsKey(cur)){                windowMap.put(cur, windowMap.getOrDefault(cur, 0)+1);                if(windowMap.get(cur).equals(targetMap.get(cur))) count++; // 注意：这里是Integer，一定得用equals，而不是==            }            while(targetMap.size()==count){                if(end-start&lt;minLen){                    minLen=end-start;                    minStart=start;                    minEnd=end;                }                char expired=s.charAt(start++);                if(targetMap.containsKey(expired)){                    if(targetMap.get(expired).equals(windowMap.get(expired))) count--;                    windowMap.put(expired, windowMap.get(expired)-1);                }            }        }        return s.substring(minStart, minEnd);    }}\n\n","tags":["LeetCode","算法"]}]