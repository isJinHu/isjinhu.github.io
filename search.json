[{"title":"Docker + Nginx部署前端项目","url":"/2024/05/10/Docker-Nginx%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/","content":"后端部署可以查看：GitHub Actions &amp; Docker实现自动化部署 | Jin’s Blog (isjinhu.github.io)\n\n\nDocker + Nginx部署前端项目此处省略Docker安装步骤。\nsudo docker run --rm hello-world # 使用该命令可以测试docker是否安装成功\n\nStep 1: 拉取Nginx镜像docker pull nginx # 拉取镜像，没有指定版本会默认下载最新 \n\nStep 2: 创建挂载目录# 注意当前路径切换mkdir -p nginx/htmlmkdir -p nginx/logsmkdir -p nginx/confcd nginxchomd 777 html logs conf\n\nStep 3: 启动一个不挂载的容器docker run -d --name nginx -p 1000:80 nginx\n\n\n--name nginx：指定容器名称\n-p 1000:80 映射端口（宿主机:容器）\n这里可以自选端口，使用lsof -i:1000查看端口是否被占用\n\n\n-d 守护进程运行\n\nStep 4: 拷贝容器内默认配置docker cp nginx:/etc/nginx/nginx.conf nginx/conf/nginx.confdocker cp nginx:/etc/nginx/conf.d nginx/conf/conf.ddocker cp nginx:/usr/share/nginx/html nginx/\n\nStep 5: 停止、删除容器docker stop nginx # 停止容器docker rm nginx # 删除容器docker ps -a # 查看所有容器\n\nStep 6: 部署前端项目\n将前端项目目录（vue项目build后的dist目录）上传至nginx/html目录下，并修改nginx/conf.d/default.conf文件。\n\n内容可以参考，其中proxy_pass记得修改为对应部署的后端地址，listen为前端的端口。\n  server {    listen 1001;    location / {        root /usr/share/nginx/html/hmdp;    }    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   /usr/share/nginx/html;    }    location /api {        default_type  application/json;        #internal;        keepalive_timeout   30s;        keepalive_requests  1000;        #支持keep-alive        proxy_http_version 1.1;        rewrite /api(/.*) $1 break;        proxy_pass_request_headers on;        #more_clear_input_headers Accept-Encoding;        proxy_next_upstream error timeout;        proxy_pass http://127.0.0.1:8081;        # proxy_pass http://backend;    }}# upstream backend {#     server 127.0.0.1:80 max_fails=5 fail_timeout=10s weight=1;#     server 127.0.0.1:8082 max_fails=5 fail_timeout=10s weight=1;# }\n\nStep 7: 运行镜像，其中-p指定对应的端口映射。docker run \\                  -p 1000:80 \\-p 1001:1001 \\--name nginx \\-v /home/ubuntu/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /home/ubuntu/nginx/conf/conf.d:/etc/nginx/conf.d \\-v /home/ubuntu/nginx/logs:/var/log/nginx \\-v /home/ubuntu/nginx/html:/usr/share/nginx/html \\-d nginx:latest\n\n","categories":["Docker"],"tags":["Docker"]},{"title":"GitHub Actions & Docker实现自动化部署","url":"/2024/05/10/GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/","content":"关于使用GitHub Actions 和 Docker部署SpringBoot后端项目。\n\n\nGitHub Actions + Docker实现自动化部署可以先看一下这个教程：GitHub Actions工作流自动化的入门核心_哔哩哔哩_bilibili\nSpringBoot多环境切换\n参考: 31 SpringBoot多环境的切换(生产环境、开发环境、测试环境)_spring boot生产和开发环境-CSDN博客\n\nStep 1: 在resources/下创建application-dev.yaml和application-prouct.yaml文件，分别表示开发环境和生产环境。\nStep 2: 在两份配置文件中分别自定义配置，例如：\n\n\nStep 3: 在application.yaml文件中引用：\n\n\nStep 4: 激活配置文件：\n\n配置文件：在配置文件中指定spring.profiles.active=dev\n虚拟机参数：在VM options指定 -Dspring.profiles.active=dev\n命令行参数：java -jar xxx.jar –spring.profiles.active=dev\n\nIDEA中使用第二种即可，部署时使用命令行参数指定。\nDockerfile文件编写在项目根目录下，新建Dockerfile，内容如下：\nFROM fabric8/java-alpine-openjdk11-jreENV TZ=Asia/ShanghaiRUN rm -f /etc/localtime \\&amp;&amp; ln -sv /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \\&amp;&amp; echo \"Asia/Shanghai\" &gt; /etc/timezoneCOPY target/*.jar /app.jarENTRYPOINT [\"java\",\"-jar\",\"/app.jar\", \"--spring.profiles.active=product\"]\n\n注意：最后一行指定了配置文件。\nworkflow文件编写以下两种方式二选一即可。\n使用GitHub提供的Ubuntu环境在项目根目录下，新建./github/workflows/delpoy.yml文件，内容如下：\n# 使用Github Actions自动部署Spring Boot项目到服务器name: Deploy With Dockeron:  push:    branches: [ master ]jobs:  build:    name: Build工作    runs-on: ubuntu-latest # 使用GitHub提供的Ubuntu环境    steps:      - name: 读取仓库内容        uses: actions/checkout@v4      - name: 设置Java环境        uses: actions/setup-java@v4        with:          java-version: 11          distribution: 'adopt'          cache: 'maven'      #      - name: 缓存Maven依赖      #        uses: actions/cache@v3      #        with:      #          path: ~/.m2/repository      #          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}      #          restore-keys: |      #            ${{ runner.os }}-maven-      - name: 编译打包        run: mvn package -Dmaven.test.skip=true      - name: 登录到DockerHub        uses: docker/login-action@v3        with:          username: ${{ secrets.DOCKER_USERNAME }}          password: ${{ secrets.DOCKER_PASSWORD }}      - name: 构建Docker镜像        uses: docker/build-push-action@v5        with:          context: .          file: ./Dockerfile          push: true          tags: ${{ secrets.DOCKER_USERNAME }}/project-name:latest      - name: 部署到服务器        uses: appleboy/ssh-action@master        with:          host: ${{ secrets.SERVER_HOST }}          username: ${{ secrets.SERVER_USERNAME }}          port: ${{ secrets.SERVER_PORT }}          password: ${{ secrets.SERVER_PASSWORD }}          script: |            sh /path/to/delpoy.sh\n\nproject-name记得替换为自己的项目名称\n其中deploy.sh脚本内容如下（记得替换{{}}中内容，端口记得按需修改）：\ndocker pull {{username}}/{{project-name}}:latestdocker tag docker.io/{{username}}/{[project-name]}:latest {{project-name}}:latestdocker rm -f {{project-name}}docker run --name {{project-name}} -p 1002:8081 -d {{project-name}}:latestdocker image prune -af\n\nDockerHub记得先注册账号。如果Dockerhub上传的是私密镜像，记得在服务器登录账号：docker login\n在GitHub项目设置中添加yml文件中的secrets，位置如下：\n\n\n使用自己的服务器Step 1: 添加Runner\n\n\nStep 2: 选择服务器对应系统，按照所示步骤在服务器上执行即可：\n\n\n\n其中，运行config.sh脚本记得使用非root用户，否则会报错。\n其次./run.sh命令改为nohup ./run.sh &amp;在后台不挂断运行。\n\nStep 3: 在服务器记得安装maven和Java\nsudo apt updatesudo apt install mavenmvn --version # 验证是否安装成功\n\n\n参考：如何在 Ubuntu 20.04 上安装 Apache Maven-腾讯云开发者社区-腾讯云\n\nStep 4: 在项目创建workflow文件，内容如下：\nname: Deploy With Runneron:  push:    branches: [ master ]jobs:  build:    name: Build工作    runs-on: self-hosted # 使用自己的服务器    steps:      - name: 读取仓库内容        uses: actions/checkout@v4      - name: 设置Java环境        run: |          pwd          java --version          mvn --version      - name: 编译打包        run: mvn package -Dmaven.test.skip=true      - name: 构建Docker镜像        run: |          docker build -f Dockerfile -t {{project-name}}:latest .      - name: 部署到服务器        run: |          docker rm -f {{project-name}          docker run -d --name {{project-name}} -p 1002:8080 {{project-name}}:latest          docker ps\n\n端口记得按需修改\n开始自动化部署将代码提交到GitHub后，在GitHub的Actions就能发现正在自动化部署。\n参考\n使用Github Actions + Docker 部署Spring Boot应用 - 掘金\nGithub Actions实现Spring Boot自动化部署（第二弹）_JavaGPT的技术博客_51CTO博客\n\n","tags":["Docker","GitHub"]},{"title":"GitHub Pages & Hexo 搭建博客","url":"/2023/08/28/GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","content":"关于如何使用GitHub Pages和Hexo搭建个人博客并进行写作（使用Keep主题）。\n\n\nGitHub Pages &amp; Hexo 搭建博客Hexo 安装与配置\nHexo 安装与配置 | Easy Hexo 👨‍💻\n\n\n确认本地已经安装 Git 和 Node.js\n安装hexo: npm install -g hexo-cli\n在本地创建一个文件夹，然后往这个文件夹中安装Hexo\n配置 Hexo，其配置文件为_config.yml：配置 Hexo | Easy Hexo 👨‍💻\n\nnpm install -g hexo-cli # 安装Hexomkdir mkdir &lt;your_blog_name&gt;  # 建立你的网站根目录，名字可以自己修改hexo init &lt;your_blog_name&gt; # 往这个文件夹中安装Hexo\n\n使用GitHub Pages部署到GitHub\n部署 Hexo | Easy Hexo 👨‍💻\n\nStep 1: 创建一个仓库：&lt;username&gt;.github.io\nStep 2: 在（&lt;username&gt;.github.io）安装部署插件\nnpm install hexo-deployer-git --savenpm install hexo-server --save\n\nStep 3: 部署到 GitHub\nhexo clean &amp;&amp; hexo d -g\n\nGitHub保存博客项目的源代码# 本地博客项目根目录下运行git initgit checkout -b hexo # 切换分支git add .git commit -m \"init\"git remote add origin git@github.com:isJinHu/isjinhu.github.io.git # 添加远程仓库git remote -vgit push origin hexo:hexo # push到远程仓库的hexo分支\n\nKeep主题安装与配置\nhome_article | Keep 主题使用手册 &amp;&amp; XPoet's Blog\n\nStep 1: 安装Keep主题\ncd &lt;your_blog_name&gt;npm install hexo-theme-keep\n\nStep 2: 使用Keep主题：在 Hexo 配置文件 _config.yml 中将 theme 设置为 keep。\ntheme: keep\n\nStep 3：配置Keep主题：在文件夹下创建一个 _config.keep.yml文件，参照文档进行配置：base_info | Keep 主题使用指南\n其他：\n\n可能用到的命令：\nnpm install hexo-theme-keep # 安装 keep 主题npm install hexo-filter-mathjax # 安装显示数学公式的插件npm install hexo-generator-searchdb # 安装站内搜索插件npm install hexo-wordcount # 安装统计字数插件hexo new page about # hexo创建页面命令，使用该命令创建about页面。\n数学公式 | Keep 主题使用指南：建议开启。\n\n配置时的图标文件可以放在 source/images文件夹中。\n\nGitalk设置：comment | Keep 主题使用指南\n\n\n默认博客模板在 scaffolds/post.md中可以设置默认模板，比如默认打开公式渲染等。\ntitle: {{ title }}date: {{ date }}mathjax: truetags:\n\n图片插入：结合TyporaStep 1：修改 _config.yml文件\npost_asset_folder: true # 将这个配置项改为true，这样hexo new “postname\"时会创建一个同名文件夹marked:  prependRoot: true  postAsset: true\n\nStep 2：安装插件\nnpm install hexo-asset-img --savenpm install hexo-renderer-marked --save\n\nStep 3: 设置Typora插入图片时路径：${filename}\nHexo deploy失败？\n执行Hexo d报错Spawn failed， 以及OpenSSL SSL_read: Connection was reset, errno 10054_copying files from extend dirs…warning: in the w_Candle_light的博客-CSDN博客\n\nhexo config deploy.repository git@github.com:isjinhu/isjinhu.github.io.git\n\n其他链接Hexo 如何隐藏文章 - yangstar - 博客园\n","tags":["GitHub","Hexo"]},{"title":"JVM笔记","url":"/2024/07/05/JVM%E7%AC%94%E8%AE%B0/","content":"\nJVM基础概念：JVM内存区域划分、类加载机制\n垃圾回收：JVM垃圾回收算法\nJVM实战：OOM移除场景分析&amp;工具&amp;排查思路\n进阶：JMM，从字节码层面分析Java基础特性&amp;并发问题，Java Agent\n\n\n\nJVM基础\nJava为什么需要JVM？\nJVM运行原理？\nJava代码如何运行？\n\nJVM和OS关系\n对于其他语言，比如C++编译成二进制文件后，OS就能直接识别运行，这样对于不同平台，需要再次编译。\n但是Java在javac编译为二进制字节码文件后，需要JVM去执行其中的指令，JVM与OS交互，从而实现跨平台。\n因此，JVM可以看成一种OS，字节码文件是汇编语言，Java语言会编译（翻译）成这种汇编，再交给JVM运行。\n"},{"title":"LeetCode刷题笔记: 回溯&贪心&动态规划","url":"/2024/05/14/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E5%9B%9E%E6%BA%AF-%E8%B4%AA%E5%BF%83-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"回溯就是暴力穷举，是一种搜索方式，其核心思想是从一个初始状态出发，深度优先搜索遍历所有可能的解决方案（解空间），如果确定某种方案不可行就回溯到上一步重新搜索。一般用来解决组合问题（无序）、子集问题（无序）、排列问题（有序）、字符串切割问题、棋盘问题等。\n贪心算法的思想是在每个决策阶段，选择局部最优解，以此获取全局最优解。\n动态规划\n\n\n回溯回溯就是暴力穷举，其核心思想是从一个初始状态出发，深度优先搜索遍历所有可能的解决方案（解空间），当遇到正解就记录，直到找到解或者尝试所有可能后终止。\n可以解决：\n\n组合问题：n个数取满足规则的k个数\n子集问题：n个数有多少符合条件的子集\n排列问题：n个数按一定规则的全排列有几种方式\n字符串分割问题：字符串按一定规则有几种切割方式\n棋盘问题：N皇后、数独等\n\n一般需要考虑3个问题：\n\n路径：已经做出的选择\n选择列表：可以做的选择\n结束条件：无法再做选择的条件\n\nresult = []def backtrack(path, choices):    if 满足结束条件:        result.add(path)        return    for choice in choices:        记录选择        backtrack(path, choices)        撤销选择\n\n\n回溯算法解题套路框架 | labuladong 的算法笔记\n代码随想录\n\n组合问题77. 组合 - 中等77. 组合 - 力扣（LeetCode）\n思路：\n46. 全排列 - 中等46. 全排列\n思路：这题是回溯的经典应用。按我们自己穷举全排列的思路，首先选择第一个的数字，下一个的数字在剩下的数字列表中选择，这样直到所有的数字都选完。所以我们需要记录之前已经选过的数字，从没选过的数字中进行当前阶段的选择。\n具体来说，我们可以从第0个位置开始，递归选择每个没被选过的数字，选择完所有元素就回溯撤销选择。\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; res;    List&lt;Integer&gt; path;    int[] nums;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {        this.res=new ArrayList&lt;&gt;();        this.path=new ArrayList&lt;&gt;(nums.length);        this.nums=nums;        dfs(0, new boolean[nums.length]);        return res;    }    private void dfs(int i, boolean[] used){        if(nums.length==i){            res.add(new ArrayList&lt;&gt;(path));            return;        }        for(int j=0;j&lt;nums.length;j++){            if(!used[j]){                path.add(nums[j]); // 选择                used[j]=true;                dfs(i+1, used); // 递归                path.remove(i); // 撤销选择                used[j]=false;            }        }    }}\n\n78. 子集 - 中等78. 子集\n思路：对于每个数字我们可以选或者不选，因此第i层就是对会有对第i个数字选或者不选两个选项。\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; res;    List&lt;Integer&gt; path;    int[] nums;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {        this.res=new ArrayList&lt;&gt;();        this.path=new ArrayList&lt;&gt;();        this.nums=nums;        dfs(0);        return res;    }    private void dfs(int i){        if(i==nums.length){            res.add(new ArrayList&lt;&gt;(path));            return;        }        // 选这个数字        path.add(nums[i]);        dfs(i+1);\t\t// 不选这个数字        path.remove(path.size()-1);         dfs(i+1);        // 撤销选择：需要注意这里的撤销选择只的是对这个数字的选择行为本身（回到的是选择上一个数字的状态），而不是选这个数字    }}\n\n39. 组合总和 - 中等39. 组合总和\n思路：对于每个节点，我们都可以\n贪心45. 跳跃游戏 II - 力扣（LeetCode）","tags":["LeetCode","算法"]},{"title":"LeetCode刷题笔记：数组&双指针","url":"/2024/05/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/","content":"\n\n双指针双指针算法是一类用2个指针遍历数组或链表的算法，通常用来解决在数据中进行搜索、排序、匹配的问题。\n同向双指针同向双指针也可叫快慢双指针，一般慢指针每次移动一步，快指针则移动两步或更多步。\n一般用来解决链表问题。\n用在数组中，可以解决有序数组要根据一定条件原地创建新数组这样一类问题。具体来说，快指针指向旧数组当前遍历位置，慢指针指向新数组长度（下一个元素要放置的位置），根据新旧数组判断快指针指向的元素是否可以加入新数组，如88. 合并两个有序数组、27. 移除元素、26. 删除有序数组中的重复项、80. 删除有序数组中的重复项 II 。\n88. 合并两个有序数组88. 合并两个有序数组\n\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n\n从两个数组末尾遍历，慢指针指向下一个元素将要放置的位置，2个快指针分别指向2个数组当前正在对比的元素，哪个数字更大就放置在慢指针指向位置，然后再移动指针。\nclass Solution {    public void merge(int[] nums1, int m, int[] nums2, int n) {        // 同向双指针        int slow=m+n-1;        int fast1=m-1, fast2=n-1;        while(fast1&gt;=0&amp;&amp;fast2&gt;=0){            if(nums1[fast1]&gt;nums2[fast2]){                nums1[slow--]=nums1[fast1--];            }else{                nums1[slow--]=nums2[fast2--];            }        }        while(fast2&gt;=0){            nums1[slow--]=nums2[fast2--];        }    }}\n\n27. 移除元素27. 移除元素\n\n输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2,,]解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）\n\n慢指针指向下一个元素将要放置的位置，快指针指向当前遍历位置，如果这个数是要移除的元素，快指针后移，否则将其复制到慢指针指向位置再后移。\nclass Solution {    public int removeElement(int[] nums, int val) {        // 同向双指针        int slow=0, fast=0;        while(fast&lt;nums.length){            if(nums[fast]!=val){                nums[slow++]=nums[fast];            }            fast++;        }        return slow;    }}\n\n26. 删除有序数组中的重复项26. 删除有序数组中的重复项\n\n输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n慢指针指向下一个元素将要放置的位置（相当于新数组长度位置），快指针指向当前遍历位置。\n如果快指针指向的元素已经在新数组中slow-1位置出现，那么就重复，快指针直接后移，否则复制到慢指针位置再后移。\nclass Solution {    public int removeDuplicates(int[] nums) {        // 同向双指针        if(nums.length==1) return 1;        int slow=1, fast=1;        while(fast&lt;nums.length){            if(nums[fast]==nums[slow-1]){                fast++;            }else{                nums[slow++]=nums[fast++];            }        }        return slow;    }}\n\n80. 删除有序数组中的重复项 II80. 删除有序数组中的重复项 II\n\n输入：nums = [1,1,1,2,2,3]输出：5, nums = [1,1,2,2,3]解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素\n\n慢指针指向下一个元素将要放置的位置（相当于新数组长度位置），快指针指向当前遍历位置。\n如果当前元素与新数组的倒数第二个数一样，说明新数组已出现2次该数，该数不需要加入新数组，快指针直接后移，否则复制后再后移。\nclass Solution {    public int removeDuplicates(int[] nums) {        if(nums.length&lt;3) return nums.length;        int slow=2, fast=2;        while(fast&lt;nums.length){            if(nums[slow-2]!=nums[fast]){                nums[slow++]=nums[fast++];            }else{                fast++;            }        }        return slow;    }}\n\n数组169. 多数元素-摩尔投票169. 多数元素 - 力扣（LeetCode）\n寻找长度为n的数组中出现次数大于 ⌊ n/2 ⌋ 的多数元素。\n\n输入：nums = [3,2,3]输出：3\n\n摩尔投票\n\n记多数元素的票为1，其他为-1，那么所有数字的票数和一定&gt;0\n若前a个数字票数和=0，那么剩余的n-a个数字的票数和一定&gt;0，多数元素依旧不变。\n\n因此，票数和=0时，可以缩小剩余数组区间。假设首个元素n为多数元素x，那么当n=x时，抵消的元素中一半是多数元素x；当n!=x时，抵消的多数元素可能是0-一半。因此最后一轮假设的必定是多数元素。\n\n多数元素为t个，t&gt;n/2，2(n-t)&lt;n，因此抵消到最后剩余的必定是多数元素为首的数组。\n\nclass Solution {    public int majorityElement(int[] nums) {        int x=0, votes=0;        for(int n:nums){            if(votes==0) x=n;            votes += n == x ? 1 : -1;        }        return x;    }}\n\n189. 轮转数组 #todo 旋转平移类189. 轮转数组 - 力扣（LeetCode）\n首先反转整个数组，然后反转前k个，反转后n-k个，就是轮转后的数组。\n注意：k=k%n。\nclass Solution {    public void rotate(int[] nums, int k) {        int n=nums.length;        k=k%n;        if(k==0) return;        reverse(nums, 0, nums.length-1);        reverse(nums, 0, k-1);        reverse(nums, k, nums.length-1);    }    private void reverse(int[] nums, int start, int end){        while(start&lt;end){            int tmp=nums[start];            nums[start++]=nums[end];            nums[end--]=tmp;        }    }}\n\n121. 买卖股票的最佳时机121. 买卖股票的最佳时机 - 力扣（LeetCode）\n只能在某天买入，未来某天卖出。\n\n输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\n思路：只要知道这天之前最低是多少，就是当日最大利润，因此遍历时记录min以及当前利润，更新最大利润即可。\nclass Solution {    public int maxProfit(int[] prices) {        int minPrice=prices[0];        int res=0;        for(int i=1;i&lt;prices.length;i++){            res=Math.max(res, prices[i]-minPrice);            minPrice=Math.min(minPrice, prices[i]);        }        return res;    }}\n\n122. 买卖股票的最佳时机 II - 力扣（LeetCode）在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n\n输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。     总利润为 4 + 3 = 7 。\n\n思路：只要比前一天高，就买入，第二天就卖出。\nclass Solution {    public int maxProfit(int[] prices) {        int res=0;        for(int i=1;i&lt;prices.length;i++){            if(prices[i]&gt;prices[i-1]){                res+=prices[i]-prices[i-1];            }        }        return res;    }}\n\n55. 跳跃游戏 - 力扣（LeetCode）- 动态规划给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。\n\n输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n思路：对于每个位置\n","tags":["LeetCode","算法"]},{"title":"LeetCode刷题笔记：栈&单调栈&单调队列","url":"/2024/05/11/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A0%88-%E5%8D%95%E8%B0%83%E6%A0%88-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","content":"栈是一种「先进后出」的数据结构。单调栈是一种特殊的栈，在满足「先进后出」规则基础上，同时满足「从栈底到栈顶的元素单调递增/减」，因此也分为单调递增栈，单调递减栈。\n单调栈用来解决下一个更大/小元素、上一个更大/小元素这一类的典型问题。比如739. 每日温度，84. 柱状图中最大的矩形，42. 接雨水都是这类问题。\n队列是一种「先进先出」的数据结构。单调队列是一种特殊的队列，在满足「先进先出」规则基础上，同时满足「从队首到队尾的元素单调递增/减」。\n单调队列用来解决滑动窗口内的最大/小值、中位数的动态查询这一类问题。比如239. 滑动窗口最大值。\n\n\n单调栈这里以单调递减栈为例，可以解决求下一个更大元素问题。\n单调递减栈的思想是：只有比栈顶元素小的元素才能直接进栈，否则需要将栈中更小的元素出栈。这样，当元素出栈时，就找到了下一个更大元素。\n739. 每日温度 - 中等739. 每日温度：给定一个表示每日温度的整数数组，求对于每天在第几天后温度会比这天更高，如果没有，填0。\n\n输入: temperatures = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n\n思路：求的是下一个更大元素的索引距离，用单调递减栈，栈中记录的实际上是还没算出「下一个更大元素」的数字下标。\n时间复杂度：O(n)，每个元素只进出栈一次。\nclass Solution {    public int[] dailyTemperatures(int[] temperatures) {        int length=temperatures.length;        int[] res=new int[length];        Deque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;(); // 单调栈        for(int i=0;i&lt;length;i++){            while(!stack.isEmpty()&amp;&amp;temperatures[i]&gt;temperatures[stack.peekLast()]){                int j=stack.pollLast();                res[j]=i-j;            }            stack.offerLast(i);        }        // while(!stack.isEmpty()){        //     res[stack.pollLast()]=0;        // }        return res;    }}\n\n84. 柱状图中最大的矩形 - 困难84. 柱状图中最大的矩形：给定柱状图中每个柱子高度，求能勾勒出的矩形最大面积。\n\n\n\n输入：heights = [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10\n\n思路1：想要以某个柱子为高，那么必须知道这个柱子左右侧更矮柱子的下标，即要求更小元素下标。因此用2个单调递增栈，分别求上/下一个更小元素并保存，最后在遍历求面积即可。\n思路2：计算右侧更矮柱子的下标时，单调栈用于维护没有找到右侧更矮柱子的柱子索引，当某个元素出栈时，说明这个元素找到右侧更矮柱子，同时新的栈顶元素（如果存在）一定是当前出栈柱子左侧更矮的柱子。（因为如果左侧有更高的柱子，都已经出栈，而更矮的柱子会留在里面）\nclass Solution {    public int largestRectangleArea(int[] heights) {        Deque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;();        int res=0;        for(int i=0;i&lt;heights.length;i++){            while(!stack.isEmpty()&amp;&amp;heights[i]&lt;heights[stack.peekLast()]){                int curHeight=heights[stack.pollLast()];                int leftIdx=0;                if(!stack.isEmpty()){                    leftIdx=stack.peekLast()+1;                }                int area=curHeight*(i-leftIdx);                res=Math.max(res,area);            }            stack.offerLast(i);        }        while(!stack.isEmpty()){            int curHeight=heights[stack.pollLast()];            int leftIdx=0;            if(!stack.isEmpty()){                leftIdx=stack.peekLast()+1;            }            int area=curHeight*(heights.length-leftIdx);            res=Math.max(res,area);        }        return res;    }}\n\n42. 接雨水 - 困难单调栈做法42. 接雨水\n\n\n思路：当我们找到右侧第一个比某个位置大的元素时，这里就能接水，相当于横着计算。\n\n\nclass Solution {    public int trap(int[] height) {        // 单调栈做法        Deque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;();        int res=0;        for(int i=0;i&lt;height.length;i++){            while(!stack.isEmpty()&amp;&amp;height[stack.peekLast()]&lt;=height[i]){                int curHeight=height[stack.pollLast()];                if(stack.isEmpty()) break;                int left=stack.peekLast();                int h=Math.min(height[left], height[i])-curHeight;                res+=h*(i-left-1);            }            stack.offerLast(i);        }        return res;    }}\n\n双指针做法思路：\n\n某个位置能接的水=min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。\n使用相向双指针遍历分别记录左右两侧当前最大值，其中较小的那个就是公式用到的那个。\n\n时间复杂度：O(n)，空间复杂度：O(1)。\nclass Solution {    public int trap(int[] height){        // 双指针做法: min{lMax, rMax}-h[i], lMax=max{0,...,i}        int res=0;        int left=0, right=height.length-1;        int lMax=height[0], rMax=height[right];        while(left&lt;=right){            if(lMax&lt;rMax){                lMax=Math.max(lMax, height[left]);                res+=lMax-height[left++];            }else{                rMax=Math.max(rMax, height[right]);                res+=rMax-height[right--];            }        }        return res;    }}\n\n单调队列单调队列的思想是：只有当一个元素是最值或者可能成为最值时才保留，否则出队。这样，每次移动窗口时，队首就是当前窗口最值。\n239. 滑动窗口最大值 - 困难239. 滑动窗口最大值\n\n\n思路：对于窗口[1 3 -1]，其中3是最大值，3之前的数字1比3小且更早离开，所以无论窗口如何移动都不会成为最大值，3之后的数字-1比3小但更晚离开，因此可能成为最大值。每次移动时，需要判断队首的最值是否离开窗口，判断队内的旧数字是否还可能成为新的最值，如果比新数字小就不可能，需要出队；否则可能，保留，然后再将新数字入队。\nclass Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        Deque&lt;Integer&gt; queue=new ArrayDeque&lt;&gt;();        int[] res=new int[nums.length-k+1];        // i指向即将入栈的元素，j指向即将出栈的元素        for(int i=0, j=-k+1;i&lt;nums.length;i++,j++){            // 加入新元素，让窗口大小保持为k            while(!queue.isEmpty()&amp;&amp;queue.peekLast()&lt;nums[i]){                queue.pollLast();            }            queue.offerLast(nums[i]); // 入队            if(j&lt;0) continue;            // 计算当前窗口最值            res[j]=queue.peekFirst();            // 移动窗口            if(queue.peekFirst()==nums[j]){                queue.pollFirst();            }        }        return res;    }}\n\n栈：394. 字符串解码394. 字符串解码\nclass Solution {    public String decodeString(String s) {        StringBuilder res=new StringBuilder();        int times = 0;        LinkedList&lt;Integer&gt; timesStack=new LinkedList&lt;&gt;();        LinkedList&lt;String&gt; substrStack=new LinkedList&lt;&gt;();        for(int i=0;i&lt;s.length();i++){            char c=s.charAt(i);            if(c&gt;='0'&amp;&amp;c&lt;='9'){                times=times*10+Integer.parseInt(c+\"\");            }else if(c == '['){                timesStack.add(times);                substrStack.add(res.toString());                times=0;                res=new StringBuilder();            }else if(c==']'){                int curTimes=timesStack.pollLast();                StringBuilder str=new StringBuilder();                while(curTimes--!=0) str.append(res);                res=new StringBuilder(substrStack.pollLast()+str);            }else{                res.append(c);            }        }        return res.toString();    }}\n\n","tags":["LeetCode","算法"]},{"title":"Netty笔记：基础概念&技术架构&核心组件","url":"/2024/07/03/Netty%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/","content":"Netty是对Java NIO的高级封装，大大简化了网络应用的开发，并对拆包/粘包、数据编解码、TCP断线重连等一系列问题提供了现成的解决方案。\n作为一个网络应用框架，本文将从Netty的基础概念、技术架构、核心组件等方面对Netty进行剖析。\n\n\n基础概念什么是用户态和内核态？\n根据进程访问资源特点，可以将进程分为用户态和内核态两个级别。用户态运行的进程只能访问有限的资源，进行受限的操作；而内核态运行的进程可以访问所有资源，进行任意操作，包括读写磁盘、网络通信等。\nI/O操作是什么？IO操作是指计算机与外部世界进行数据交换的过程，可以分为2个阶段：\n\nI/O调用阶段：用户进程向内核发起系统调用。\nI/O执行阶段：内核等待I/O请求处理完成返回。该阶段分为两个过程：首先等待数据就绪，并写入内核缓冲区；随后将内核缓冲区数据拷贝至用户态缓冲区。\n\n\n\n5种I/O模型在《UNIX网络编程》中，根据不同的交换数据方式，将I/O模型分为5种：\n\n同步阻塞I/O（Blocking I/O）\n\n用户进程发起I/O请求后，一直阻塞等待内核返回数据。\n这样会导致单线程只能处理一个I/O请求，无法同时处理多个I/O请求。因此，想要提高吞吐量，只能通过增加线程数，但线程数过多会导致线程切换开销增大。\n\n\n同步非阻塞I/O（Non-blocking I/O）\n\n用户进程发起I/O请求后，不会阻塞等待内核返回数据，而是立即返回。\n之后用户进程需要通过轮询的方式，不断查询内核是否有数据返回。\n优点是不会阻塞，但需要不断轮询，存在大量上下文切换操作，会导致CPU资源浪费。\n\n\nI/O复用（I/O Multiplexing）\n\n多路复用技术通过select/poll/epoll等系统调用，实现了一个线程处理多个I/O操作，即通过一个线程监听多个Channel，当某个Channel有数据可读时，才会触发事件。\n与NIO类似，发起I/O请求后，不会阻塞等待内核返回数据，而是立即返回，之后用户线程通过select调用获取多个数据通道的数据状态，再进行实际的读写操作。\n优点是一个线程管理多个IO通道，减少了线程切换开销，提高了系统IO吞吐量，适合大量连接但数据量小的场景。\n\n\n信号驱动I/O（Signal Driven I/O）\n\n用户进程发起I/O请求后，会给对应socket注册一个信号函数，然后返回。内核在数据准备好后，发送SIGIO信号通知用户进程进行数据读取。\n\n\n异步I/O（Asynchronous I/O）\n\n用户进程发起I/O请求后，不会阻塞等待内核返回数据，而是立即返回，之后内核会在数据准备好后，将数据从内核缓冲区复制到用户缓冲区，再通知用户进程数据已准备好。\n与NIO区别在于，NIO是用户进程主动轮询内核是否有数据返回，而异步I/O是内核主动通知用户进程数据已准备好。\n与信号驱动I/O相比，信号驱动I/O是用户进程去复制数据，而异步I/O不需要用户进程参与数据复制，会直接将数据从内核缓冲区复制到用户缓冲区，是完全异步非阻塞的。\n优点是用户进程完全不会阻塞，且不需要用户进程轮询，适合大量连接且数据量大的场景。\n\n\n\n怎么区分同步非阻塞和多路复用这两种IO模式呢？\n个人理解是，从概念角度看，不同的IO模型的区别在于数据交换过程。同步非阻塞侧重于线程不断轮询，多路复用则侧重于一个线程监听多个Channel。\n但是从Java NIO来看，NIO包的三大组件Buffer、Channel、Selector就是对多路复用的封装实现。\n为什么IO多路复用比多线程更高效？\n多路复用技术通过一个线程监听多个Channel，当某个Channel有数据可读时，才会触发事件。这样，一个线程就可以处理多个I/O请求，减少了线程切换开销，提高了系统IO吞吐量。\n但核心在于多路复用将对多个Channel的轮询监听交给了内核，减少了用户态和内核态的切换。\n为什么IO多路复用可以增加吞吐量？\n吞吐量的提升一是体现在少量线程处理大量连接，减少了线程切换开销；二是体减少了用户态和内核态的切换，减少上下文切换开销，三是Netty还通过高效的事件驱动机制，通过异步（多线程）并行处理拆分任务，提高了系统的吞吐量。\n\n关于select/poll/epoll的区别以及其他内容，可以参考：【Redis】IO多路复用机制_redis io多路复用-CSDN博客异步IO与回调 - Evil_XJZ - 博客园\n\nLinks\nlinux和unix中的IO模型总结 - 九卷 - 博客园\n\n"},{"title":"Hello World","url":"/2023/08/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["Hexo"]},{"title":"LeetCode刷题笔记：滑动窗口","url":"/2024/09/03/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","content":"滑动窗口算法的核心思想是通过两个指针来定义一个窗口，通过动态调整窗口大小和位置来求解问题。\n通常用于解决子数组、子串、子序列相关问题，比如：最大最小子数组（最大子数组和）、（包含所有字符的/无重复字符的）子字符串、定长子数组的最大/小值、滑动窗口平均值。\n\n\n滑动窗口子串3. 无重复字符的最长子串 - 中等3. 无重复字符的最长子串 - 力扣（LeetCode）\n给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。\nclass Solution {    public int lengthOfLongestSubstring(String s) {        int res=0;        int start=0, end=0; // 滑动窗口指针        Map&lt;Character, Integer&gt; lastOccuredMap=new HashMap&lt;&gt;(); // 记录字符出现位置+1,遇到重复窗口起点应移动到此处        while(end&lt;s.length()){            char c=s.charAt(end++); // 窗口扩大            if(lastOccuredMap.containsKey(c)){ // 是否需要缩小                start=Math.max(start, lastOccuredMap.get(c));            }            res=Math.max(res, end-start);            lastOccuredMap.put(c, end);        }        return res;    }}\n\n438. 找到字符串中所有字母异位词 -中等 （类似最小覆盖子串）438. 找到字符串中所有字母异位词 - 力扣（LeetCode）\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\nclass Solution {    public List&lt;Integer&gt; findAnagrams(String s, String p) {        List&lt;Integer&gt; res=new ArrayList&lt;&gt;();        if(s.length()&lt;p.length()) return res;        Map&lt;Character, Integer&gt; targetMap=new HashMap&lt;&gt;(); // 目标窗口        Map&lt;Character, Integer&gt; windowMap=new HashMap&lt;&gt;(); // 滑动窗口记录        for(char c:p.toCharArray()){            targetMap.put(c, targetMap.getOrDefault(c,0)+1);        }        int start=0, end=0; // 滑动窗口指针        int count=0;        while(end&lt;s.length()){            char cur=s.charAt(end++);            if(targetMap.containsKey(cur)){                windowMap.put(cur, windowMap.getOrDefault(cur, 0)+1);                if(windowMap.get(cur).equals(targetMap.get(cur))) count++; // 注意：这里是Integer，一定得用equals，而不是==            }            while(targetMap.size()==count){                if(end-start==p.length()){                    res.add(start);                }                char expired=s.charAt(start++);                if(targetMap.containsKey(expired)){                    if(targetMap.get(expired).equals(windowMap.get(expired))) count--;                    windowMap.put(expired, windowMap.get(expired)-1);                }            }        }        return res;    }}\n\n567. 字符串的排列 - 中等567. 字符串的排列 - 力扣（LeetCode）\nclass Solution {    public boolean checkInclusion(String s1, String s2) {        if(s1.length()&gt;s2.length()) return false;        Map&lt;Character, Integer&gt; targetMap=new HashMap&lt;&gt;(); // 目标窗口        Map&lt;Character, Integer&gt; windowMap=new HashMap&lt;&gt;(); // 滑动窗口记录        for(char c:s1.toCharArray()){            targetMap.put(c, targetMap.getOrDefault(c,0)+1);        }        int start=0, end=0; // 滑动窗口指针        int count=0;        while(end&lt;s2.length()){            char cur=s2.charAt(end++);            if(targetMap.containsKey(cur)){                windowMap.put(cur, windowMap.getOrDefault(cur, 0)+1);                if(windowMap.get(cur).equals(targetMap.get(cur))) count++; // 注意：这里是Integer，一定得用equals，而不是==                while(count==targetMap.size()){                    if(end-start==s1.length()){return true;}                    char expired=s2.charAt(start++);                    if(windowMap.get(expired).equals(targetMap.get(expired))) count--;                    windowMap.put(expired, windowMap.get(expired)-1);                }            }else{                windowMap=new HashMap&lt;&gt;();                count=0;                start=end;            }        }        return false;    }}\n\n76. 最小覆盖子串 - 困难76. 最小覆盖子串 - 力扣（LeetCode）\nclass Solution {    public String minWindow(String s, String t) {        if(s.length()&lt;t.length()) return \"\";        Map&lt;Character, Integer&gt; targetMap=new HashMap&lt;&gt;(); // 目标窗口        Map&lt;Character, Integer&gt; windowMap=new HashMap&lt;&gt;(); // 滑动窗口记录        for(char c:t.toCharArray()){            targetMap.put(c, targetMap.getOrDefault(c,0)+1);        }        int start=0, end=0; // 滑动窗口指针        int minLen=s.length()+1, minStart=0, minEnd=0;        int count=0;        while(end&lt;s.length()){            char cur=s.charAt(end++);            if(targetMap.containsKey(cur)){                windowMap.put(cur, windowMap.getOrDefault(cur, 0)+1);                if(windowMap.get(cur).equals(targetMap.get(cur))) count++; // 注意：这里是Integer，一定得用equals，而不是==            }            while(targetMap.size()==count){                if(end-start&lt;minLen){                    minLen=end-start;                    minStart=start;                    minEnd=end;                }                char expired=s.charAt(start++);                if(targetMap.containsKey(expired)){                    if(targetMap.get(expired).equals(windowMap.get(expired))) count--;                    windowMap.put(expired, windowMap.get(expired)-1);                }            }        }        return s.substring(minStart, minEnd);    }}\n\n","tags":["LeetCode","算法"]},{"url":"/2024/07/15/JUC%E7%AC%94%E8%AE%B0/","content":"JUC包大致可以分为5个部分：Executor（线程池）、Collections（并发集合）、Atomic（原子变量类）、Lock（锁）、Tools（同步辅助工具类）\n\n\n0. Java线程基础线程实现方式Java创建线程的方式本质只有一种：构造一个Thread类实例。\n常见实现方式的包括1）继承Thread类重写run方法，调用start方法启动线程；2）实现Runnable接口，传入Thread实例中；3）使用Callable配合Future创建有返回值的线程；4）创建线程池\n\n直接调用Thread类的run方法会在原线程中执行该方法，start方法才会调用native方法去创建新线程执行run方法。\n\n为什么实现Runnable接口比继承Thread类实现线程好？\n实现了Runnable和Thread类的解耦，Runnable负责定义执行内容，Thread负责线程启动以及其他设置，权责分明。\n使用Runnable可以使用线程池避免多次新建销毁线程\nJava不支持双继承，因此类继承Thread后无法继承其他类，但是可以实现多个接口，因此继承Thread会限制拓展性\n\n线程停止方式如果需要提前停止线程（用户关闭程序或者冲虚重启出错），可以使用interrupt方法通知线程停止。\n\n为什么不强制：强制停止可能会造成安全问题，比如文件写入强制停止会导致数据不完整。\n\nwhile (!Thread.currentThread().isInterrupted() &amp;&amp; more work to do) &#123;    do more work&#125;\n\n如果线程在阻塞、等待、计时等待等状态，线程会抛出Interrupted Exception异常，同时清除中断信号。因此，在编写子方法可能会遇到这个异常，需要抛出或者在catch再次声明中断。\n使用volatile修饰标记位停止方法不正确是因为：如果停止线程A时是通过修改这个标志位，那么如果线程A此时正好阻塞，是无法接收到这个停止信号的，但是interrupt方法就会抛出异常。因此在特殊情况，比如线程长时间阻塞，无法及时感受到中断。\n\nstop\\suspend\\resume都被废弃，可能会存在安全风险比如死锁，\n\n线程生命周期\n\nNew：new Thread()创建，但是未调用start()方法，调用后变为Runnable\nRunnable：OS中分为2种，Ready和Running，Runnable状态表示正在执行或者在等待CPU轮转\n三种阻塞：Blocked、Waiting、Timed Waiting\nBlocked：只有synchronized获取锁失败会从Runnable进入阻塞状态，而离开也只有抢到了对应的monitor锁。\nWaiting：进入Waiting状态有3中可能：\n\n没有设置 Timeout 参数的 Object.wait() 方法。\n没有设置 Timeout 参数的 Thread.join() 方法。\nLockSupport.park() 方法。\n\nJava中除了sychronized锁，其他锁（如ReentrantLock）没有抢到都会进入Waiting，因为本质是调用LockSupport.park() 方法。\n离开：只有当执行了 LockSupport.unpark()，或者 join 的线程运行结束，或者被中断时才可以进入 Runnable 状态。\n但其他线程调用notify或者notifyAll唤醒此线程，会进入Blocked状态。wait和notify、notifyAll都需要在同步代码块或者同步方法中才能使用，wait会释放锁，但notify和notifyAll不会，因此在被唤醒的线程会进入Block状态，还需要等待唤醒线程执行完毕，释放锁，才可以竞争锁，回到Runnable状态。\n\nBlocked与Waiting区别:\n\nBlocked是在等待别的线程释放monitor锁\nWaiting是在等待某个条件，比如join线程中心完毕，或者notify&#x2F;notifyAll\n\n\nTimed Waiting：与Wait类似，区别在于有时间限制，会等待超时自动唤醒或者超时前被唤醒信号唤醒\n\n设置了时间参数的 Thread.sleep(long millis) 方法；\n设置了时间参数的 Object.wait(long timeout) 方法；\n设置了时间参数的 Thread.join(long millis) 方法；\n设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。\n\n离开：与Wait类似，但超时会自动唤醒，\nTerminated：run方法执行完毕线程自动退出，或者出现未捕获的异常终止run方法，就会进入终止。进入终止后不可逆。（New和Terminated都只能有一次）\n\n注意wait可能会存在虚假唤醒，因此一般需要给一个条件来避免。\n\n为什么wait&#x2F;notify&#x2F;notifyAll在Object类，而sleep在Thread类中\n因为Java每个对象那个都有一个monitor锁，每个对象都可以上锁，这就意味着锁是对象级别，而不是线程级别，wait&#x2F;notify&#x2F;notifyAll都是锁级别操作，因为在Object这个所有类的父类中定义最合适。（而sleep则是线程级别操作，是这个线程自发的，与其他线程无关）\n如果把wait&#x2F;notify&#x2F;notifyAll定义在Thread中，会导致局限。因为一个线程可能持有多把锁，定义在Thread中无法实现持有多把锁，也无法明确持有的是哪把锁。\n\nwait&#x2F;notify和sleep异同\n它们都可以让线程阻塞。\n它们都可以响应 interrupt 中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出 InterruptedException 异常。\n\n但是它们也有很多的不同点：\n\nwait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。\n在同步代码中执行 sleep 方法时，并不会释放 monitor 锁，但执行 wait 方法时会主动释放 monitor 锁。\nsleep 方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的 wait 方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复。\nwait&#x2F;notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。\n\n线程安全典型的线程安全问题\n\n运行结果错误：i++等，通常因为并发读写\n没有在正确的时间、地点被发布和初始化导致线程安全问题\n活跃性问题：死锁、活锁和饥饿\n\n什么时候需要特别注意线程安全问题\n\n当问共享变量或资源\n依赖时序的操作：检查与执行并非原则操作，中间打断导致检查失效，需要加锁等措施保证原子性\n不同数据之间存在绑定关系：需要同时更新，因此也需要保障原子性\n对方没有声明自己是线程安全的：比如ArrayList\n\n为什么多线程会有性能问题\n调度开销：短任务的上下文切换带来的开销可能比任务本身还大；上下文切换时线程缓存失效需要重建。因此一般要避免密集上下文切换，系统存在线程最小执行时间。\n协作开销：线程之间存在共享数据，线程工作内存的数据 flush 到主存中，然后再从主内存 refresh 到其他线程的工作内存中，因此会存在多线程的协作开销。\n\n线程池线程池比手动创建线程好在哪？\n避免反复创建线程开销大：线程池可以用一些固定的线程一直保持工作状态并反复执行任务。\n避免过多线程占用太多内存资源的问题，线程池会根据需要创建线程，控制线程的总数量，避免占用过多内存资源。\n线程池还可以统一管理内存、CPU等资源，统一开始或结束任务，更易于管理且有利于数据统计。\n\n线程池参数\ncorePoolSize：核心线程数\nmaximumPoolSize：最大线程数\nThreadFactory：线程工厂，用于创建新线程\nworkQueue：存放任务的队列\nHandler：拒绝策略，用于处理被拒绝任务\nkeepAliveTime+unit：空闲线程存活时间及其单位\n\n线程池工作流程&#x2F;原理\n\n\n\n当提交任务后，\n\n如果线程池中的核心线程都在忙，并且线程池未达到最大线程数，新提交的任务会被放入队列中进行等待。\n如果任务队列已满，且当前线程数量小于最大线程数，线程池会创建新的线程来处理任务。\n如果核心线程已满，工作队列已满，线程池已满，就会根据拒绝策略拒绝任务。\n\n空闲的线程会从任务队列中取出任务来执行，当任务执行完毕后，线程并不会立即销毁，而是继续保持在池中等待下一个任务。\n当线程空闲时间超出指定时间，且当前线程数量大于核心线程数时，线程会被回收。\n4种拒绝策略\nAbortPolicy：终止策略，拒绝时抛出RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。\nDiscardPolicy：丢弃策略，拒绝时直接丢弃，不给通知。\nDiscardOldestPolicy：丢弃任务队列中头结点，但也没有通知。\nCallerRunsPolicy：新任务会交给提交任务的线程执行。\n\n6种线程池\nFixedThreadPool：核心线程数&#x3D;最大线程数，因此线程个数最大固定，任务队列size&#x3D;0，\n\nCachedThreadPool：线程数可以无线增加至Integer.MAX_VALUE，任务队列为SynchronousQueue，队列容量为0。\n\nScheduledThreadPool：定时或周期性执行任务。\n\nSingleThreadExecutor：用唯一线程去执行任务，因此所有任务顺序执行。\n\nSingleThreadScheduledExecutor：即new ScheduledThreadPoolExecutor(1)\n\nForkJoinPool：用于拆分汇总执行任务\n\n\n线程池的阻塞队列LinkedBlockingQueue：无界队列，容量默认为Integer.MAX_VALUE\nSynchronousQueue：容量为0，每次读取数据都要被阻塞，直到有数据被放入；每次放数据也被阻塞，直到有消费者来取。（只有put和take）\nDelayedWorkQueue：内部元素按照延迟的时间长短排序\n为什么不应该自动创建线程池自动创建的线程池都存在风险，手动创建可以明确线程池的运行规则，并自己选择合适的线程数和拒绝策略。\n如何选择线程数\nCPU密集型：一般是CPU核心数1-2倍。如果过多，会造成不必要的上下文切换，过少就会浪费CPU\n耗时IO型：线程数 &#x3D; CPU 核心数 *（1+平均等待时间&#x2F;平均工作时间）\n线程的平均工作时间所占比例越高，就需要越少的线程；\n线程的平均等待时间所占比例越高，就需要越多的线程；\n针对不同的程序，进行对应的实际测试就可以得到最合适的选择。\n\n\n\n线程池如何关闭\nshutdown：会等待线程池任务执行完毕后关闭，调用后提交新任务会根据拒绝策略拒绝\nisShutdown：会判断是否执行了shutdown或者shudownNow，返回true并不意味着线程池已经关闭\nisTerminated：判断线程池是否真的终结\nawaitTermination：根据传入参数，等待，返回线程池是否终结\nshutdownNow：会给线程池中所有线程发送interrupt信号，并返回所有正在等待任务列表\n\n线程池实现“线程复用”的原理线程池对Thread进行了封装，不是每次执行任务都调用start方法创建新线程，而是让每个线程执行一个循环任务，在这个循环任务中，不断检查是否有任务等待被执行，有就调用任务的run方法，\n1. 锁锁的分类偏向锁&#x2F;轻量级锁&#x2F;重量级锁\n偏向锁：不存在竞争的多，当第一个线程尝试获取锁时，会记录该线程，如果之后获取锁的线程正好是偏向锁的拥有者，就可以直接获得锁。\n轻量级锁：当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。\n重量级锁：当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。\n\n锁升级路线：无锁→偏向锁→轻量级锁→重量级锁。\n可重入锁&#x2F;非可重入锁可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。\n不可重入锁指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。\n共享锁&#x2F;独占锁共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同时被一个线程获得。\n读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。\n\n读写锁获取规则：读读共享，其他都互斥。要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。\n插队策略：\n\n公平读写锁都得排队\n非公平读写锁：写锁插队，渎锁不能插队，避免写锁获取饥饿。\n\n升降级策略：只能从写锁降级为读锁，不能从读锁升级为写锁。\n\n否则如果AB都想升级为写锁，那么就都要等待对象释放渎锁，造成死锁。\n\n\n公平锁&#x2F;非公平锁公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。\n非公平锁是在获取锁时，如果锁恰好被释放，就会直接获取锁，忽略掉已经在排队的线程，发生插队现象。\n悲观锁&#x2F;乐观锁悲观锁认为竞争一定存在，因此会在获取资源之前，必须先拿到锁，锁住资源。比如synchronized和Lock接口相关类。\n乐观锁认为竞争不一定存在，会通过cas进行资源修改。比如原子类。\n自旋锁&#x2F;非自旋锁自旋锁是在拿不到锁时，不会陷入阻塞或者释放资源，而是利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”。\n非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。\n\n自旋锁好处：避免上下文切换，提高效率；缺点如果尝试过多，也是浪费资源。因此适用并发度不高，临界区较小（拿到锁很快可以释放）\n\n可中断锁&#x2F;不可中断锁synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。\nReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。\nSynchronized原理同步代码块：会通过monitorenter和monitorexit两条命令实现\n\n执行 monitorenter 的线程尝试获得 monitor 的所有权\n如果该 monitor 的计数为 0，则线程获得该 monitor 并将其计数设置为 1。然后，该线程就是这个 monitor 的所有者。\n如果线程已经拥有了这个 monitor ，则它将重新进入，并且累加计数。\n如果其他线程已经拥有了这个 monitor，那个这个线程就会被阻塞，直到这个 monitor 的计数变成为 0，代表这个 monitor 已经被释放了，于是当前这个线程就会再次尝试获取这个 monitor。\n\n\nmonitorexit 的作用是将 monitor 的计数器减 1，直到减为 0 为止。代表这个 monitor 已经被释放了，已经没有任何线程拥有它了，也就代表着解锁，所以，其他正在等待这个 monitor 的线程，此时便可以再次尝试获取这个 monitor 的所有权。\n\n同步方法：方法会有一个ACC_SYNCHRONIZED修饰符\n当线程访问某个方法的时候，会首先检查方法是否有 ACC_SYNCHRONIZED 标志，如果有则需要先获得 monitor 锁，然后才能开始执行方法，方法执行之后再释放 monitor 锁。\n锁优化自适应的自旋锁在 JDK 1.6 中引入了自适应的自旋锁来解决长时间自旋的问题。自适应意味着自旋的时间不再固定，而是会根据最近自旋尝试的成功率、失败率，以及当前锁的拥有者的状态等多种因素来共同决定。自旋的持续时间是变化的，自旋锁变“聪明”了。比如，如果最近尝试自旋获取某一把锁成功了，那么下一次可能还会继续使用自旋，并且允许自旋更长的时间；但是如果最近自旋获取某一把锁失败了，那么可能会省略掉自旋的过程，以便减少无用的自旋，提高效率。\n偏向锁&#x2F;轻量级锁&#x2F;重量级锁\n偏向锁：不存在竞争的多，当第一个线程尝试获取锁时，会记录该线程，如果之后获取锁的线程正好是偏向锁的拥有者，就可以直接获得锁。\n轻量级锁：当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。\n重量级锁：当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。\n\n锁升级路线：无锁→偏向锁→轻量级锁→重量级锁。\n2. 并发集合HashMapHashMap为何线程不安全\n同时put碰撞导致数据丢失\n无法保证可见性\n。。。\n\nConcurrentHashMap原理Java7：在ConcurrentHashMap内部进行Segment分段，Segment 继承了 ReentrantLock，可以理解为一把锁，各个 Segment 之间都是相互独立上锁的，互不影响。相比于之前的 Hashtable 每次操作都需要把整个对象锁住而言，大大提高了并发效率。因为它的锁与锁之间是独立的，而不是整个对象只有一把锁。\n每个Segment底层和HashMap类似，依然是数组和链表，默认16个Segement。\nJava8：放弃了 Segment 的设计，采用 Node + CAS + synchronized 保证线程安全。锁粒度更细，理想情况下 table 数组元素的个数（也就是数组长度）就是其支持并发的最大个数，并发度比之前有提高。\n\n为什么不只用红黑树？\n\nTreeNode相对占用空间，短链表占用空间少、查找快\nhash分布良好时，不太会发生链表很长，用不到红黑树\n用红黑树主要是为了防止用户自己实现了不好的哈希算法导致链表过长，是一种保底策略\n\n\nHashTable底层通过sychronized关键字实现，几乎所有方法都用了synchronized修饰。\n注意：Hashtable（包括 HashMap）不允许在迭代期间修改内容，否则会抛出ConcurrentModificationException 异常，其原理是检测 modCount 变量是否等于 expectedModCount。其中 expectedModCount 是在迭代器生成的时候随之生成的，并且不会改变。它所代表的含义是当前 Hashtable 被修改的次数，而每一次去调用 Hashtable 的包括 addEntry()、remove()、rehash() 等方法中，都会修改 modCount 的值。\nCopyOnWriteArrayList适用场景：读操作可以尽可能的快，而写即使慢一些也没关系；读多写少（比如黑名单）\n当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，完成修改之后，再将原容器的引用指向新的容器。这样就完成了整个修改过程。\n同样，允许迭代期间修改，但是迭代会用一个旧数组。\n缺点：\n\n内存占用\n元素较多时复制开销大\n数据一致性不能保证\n\n阻塞队列阻塞队列和普通队列的区别在于队列空&#x2F;满时的处理。\n普通队列没有内置线程同步，因此在队列空时，移除将返回null或抛出异常；在队列满时（对于有界队列），调用add()或offer()方法将抛出异常或返回false，在多线程中使用需要通过ConcurrentLinkedQueue或者Collections.synchronizedList来保证线程安全。\n阻塞队列实现了线程安全的同步机制，在队列空时take会阻塞，直到队列有可用元素，队列满时put会阻塞，直到队列有空间。\n\n\n线程安全；2. 队列空&#x2F;满时候的处理方式\n\n\n常用方法：\n\n抛出异常：add、remove、element\n返回结果但不抛出异常：offer、poll、peek\n阻塞：put、take\n\n常见阻塞队列：\n\nArrayBlockingQueue，有界队列，创建指定容量，之后不可扩容。\n内部是用数组存储元素的，利用 ReentrantLock 实现线程安全。\n\n\nLinkedBlockingQueue，链表实现，容量默认Integer.MAX_VALUE\nSynchronousQueue：容量为0\nPriorityBlockingQueue：支持自定义优先级的阻塞队列\nPriorityBlockingQueue 是一个支持优先级的无界阻塞队列，可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。同时，插入队列的对象必须是可比较大小的，也就是 Comparable 的，否则会抛出 ClassCastException 异常。\n无界队列且支持自动扩容\n\n\nDelayQueue：具有延迟功能，放入的元素必须实现 Delayed 接口，而 Delayed 接口又继承了 Comparable 接口，所以自然就拥有了比较和排序的能力。\n\n队列的并发原理阻塞队列ReentrantLock 以及它的 Condition 来实现，而非阻塞队列ConcurrentLinkedQueue则是利用 CAS 方法实现线程安全。\n\n如果说 Lock 是用来代替 synchronized 的，那么 Condition 就是用来代替相对应的 Object 的 wait&#x2F;notify&#x2F;notifyAll，所以在用法和性质上几乎都一样。那么synchronized里面可以用Condition替代Object吗？我知道反之不可以\n\n3. 原子类原子性：操作要么全部成功，要么全部失败，不能之操作成功其中某一部分\n原子类与锁的作用区别：\n\n粒度更细：竞争被缩小到变量级别\n效率更高：因为使用CAS，不阻塞线程(非高并发情况)\n原子类使用CAS，根据JMM，为了保证原子性，我们需要进行flush（数据修改后将其刷新到主存）、refresh（从主存读取最新数据到缓存），因此会带来一定消耗\n锁虽然避免了频繁缓存操作（，通过monitor或者aqs实现线程同步，竞争锁失败会被阻塞），但是会导致频繁上下文切换。\n\n\n\n底层：UnSafe类来实现，Unsafe的getAndAddInt是通过循环 + CAS 的方式来实现的，在此过程中，它会通过 compareAndSwapInt 方法来尝试更新 value 的值，如果更新失败就重新获取，然后再次尝试更新，直到更新成功。\n原子类分类\n基本原子类 Atomic：AtomicInteger、AtomicLong、AtomicBoolean\n\n数组原子类 Atomic*Array：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray（引用类型数组原子类）\n\n引用原子类 ：AtomicReference、AtomicStampedReference（加上时间戳，解决ABA问题）、AtomicMarkableReference（与AtomicReference类似，加上了布尔值，可以表示该对象已删除）\n\n原子更新器：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater（对于之前已经定义的变量进行升级，实质通过CAS具有原子性，适合只在少数定时的时候需要原子性的变量）\n\n加法器：LongAdder、DoubleAdder\n\n加法器的作用\n是针对基本原子类的升级，内部有base和Cell[]数组\n竞争不激烈直接在base变量累加；\n激烈用Cell[]数组，每个线程会分散积累导各自对应的Cell[]数组中的某个对象，而不会共用一个，降低冲突概率（通过分段提高并发性，类似JAVA7的ConcurrentHashMap中16个Segment）\n最终通过sum方法实现多线程计数，执行时会将各线程Cell相加加上base得到总和。\n\n\n如何选择AtomicInteger还是LongAdder？\n\n低竞争时吞吐量相似，竞争激烈时LongAdder吞吐量高，但内存消耗大\nLongAdder替代不了AtomicInteger\nLongAdder只提供了add、increment等简单方法，适合统计技术求和场景\nAtomicLong还提供了compareAndSet，适合加减之外的更复杂的需要CAS的场景\n\n\n\n\n\n积累器：LongAccumulator、DoubleAccumulator\n\n\n实际上 Accumulator 就是一个更通用版本的 Adder，比如 LongAccumulator 是 LongAdder 的功能增强版，因为 LongAdder 的 API 只有对数值的加减，而 LongAccumulator 提供了自定义的函数操作。\n大量并行计算，并且计算顺序不重要，比如加法、乘法，可以使用\n原子类和volatile异同\nvolatile是用于保证可见性的，加上之后就会通过flush和refresh操作来解决可见性。\n仅仅通过volatile不能保证线程安全，因为不是原子的（原子类通过CAS实现了原子性）\n原子类可以保证可见性\n\n原子类和Sychronized异同\n原理不同：monitor vs CAS 乐观锁和悲观锁\n\n因为悲观锁的开销是固定的，也是一劳永逸的。随着时间的增加，这种开销并不会线性增长。\n而乐观锁虽然在短期内的开销不大，但是随着时间的增加，它的开销也是逐步上涨的。\n\n\n\n适用范围：原子类只针对一个对象, synchronized可以修饰方法和代码块\n\n粒度：原子类粒度小，sychronized粒度大\n\n性能：竞争激烈sychronized,不激烈原子类\n\n\n4. ThreadLocalThreadLocalMap原理？为什么key要弱引用？\n每个Thread中都有一个ThreadLocalMap，key为ThreadLocal，每次获取ThreadLocal时都会从当前线程这个map去获取，因此即便是同一个ThrealLocal对象也能得到不同的值，实现线程隔离。\n为什么要使用弱引用？因为当ThreadLocal没有其他地方引用时，应当被GC回收，使用弱引用就能让GC回收掉，避免key残留在ThreadLocalMap中（线程map中的entry强引用就会一直留着）。remove就是为了防止当ThreadLocal的键被回收，value强引用依旧存在，导致内存泄漏。JDK8之后，get和set已经加入了自动清理机制，会讲key为null的移除，但是在某些场景下长期不访问ThreadLocal变量，也不会触发，因此remove依然是保证内存安全的关键步骤。\n\n\nThreadLocalMap 解决 hash 冲突的方式是不一样的，它采用的是线性探测法。如果发生冲突，并不会用链表的形式往下链，而是会继续寻找下一个空的格子。这是 ThreadLocalMap 和 HashMap 在处理冲突时不一样的点。\n\n适用场景：\n\n每个线程独享的对象：每个线程需要一个单独的，线程之间不能共用，但不在任务中创建，会造成浪费，因此我们使用ThreadLocal为每个线程存一个就行。\n线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景：比如用户信息。前面执行的方法设置了信息后，后续方法可以通过 ThreadLocal 直接获取到，避免了传参。\n\nThreadLocal不是用来解决共享资源问题的\nThreadLocal 确实可以用于解决多线程情况下的线程安全问题，但其资源并不是共享的，而是每个线程独享的。\n\nThreadLocal 和 synchronized 是什么关系\nThreadLocal 是通过让每个线程独享自己的副本，避免了资源的竞争。\nsynchronized 主要用于临界资源的分配，在同一时刻限制最多只有一个线程能访问该资源。\n\n5. 工具类Semaphore：限制并发📚\nCompletableFuture、CountDownLatch：统一结束时间\nCountDownLatch：\n\n一个线程等待其他多个线程都执行完毕，再继续自己的工作，初始值为多个\n\n多个线程等待某一个线程的信号，同时开始执行，初始值为1个\n\n\nCyclicBarrier：可以构造出一个集结点，当某一个线程执行 await() 的时候，它就会到这个集结点开始等待，等待这个栅栏被撤销。直到预定数量的线程都到了这个集结点之后，这个栅栏就会被撤销，之前等待的线程就在此刻统一出发，继续去执行剩下的任务。\nCyclicBarrier 和 CountDownLatch 有什么异同。\n相同点：都能阻塞一个或一组线程，直到某个预设的条件达成发生，再统一出发。\n但是它们也有很多不同点，具体如下。\n\n作用对象不同：CyclicBarrier 要等固定数量的线程都到达了栅栏位置才能继续执行，而 CountDownLatch 只需等待数字倒数到 0，也就是说 CountDownLatch 作用于事件，但 CyclicBarrier 作用于线程；CountDownLatch 是在调用了 countDown 方法之后把数字倒数减 1，而 CyclicBarrier 是在某线程开始等待后把计数减 1。\n可重用性不同：CountDownLatch 在倒数到 0 并且触发门闩打开后，就不能再次使用了，除非新建一个新的实例；而 CyclicBarrier 可以重复使用，在刚才的代码中也可以看出，每 3 个同学到了之后都能出发，并不需要重新新建实例。CyclicBarrier 还可以随时调用 reset 方法进行重置，如果重置时有线程已经调用了 await 方法并开始等待，那么这些线程则会抛出 BrokenBarrierException 异常。\n执行动作不同：CyclicBarrier 有执行动作 barrierAction，而 CountDownLatch 没这个功能。\n\n6. JMM Java内存模型\nJVM内存结构是Java虚拟机运行时区域\nJMM是Java内存模型，与Java并发编程有关\n\nJMM\nJMM 是和多线程相关的一组规范，需要各个 JVM 的实现来遵守 JMM 规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。这样一来，即便同一个程序在不同的虚拟机上运行，得到的程序结果也是一致的。\nJMM屏蔽了多级缓存，定义了主内存和工作内存的概念，由JMM控制期间通信。\n\n所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容是主内存中该变量的拷贝；\n线程不能直接读 &#x2F; 写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改；\n主内存是由多个线程所共享的，但线程间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存中转来完成。\n\n指令重排序：重排序通过减少执行指令，从而提高整体的运行速度，这就是重排序带来的优化和好处。\n\n编译器优化\nCPU重排序\n内存“重排序”\n\n原子性：在编程中，具备原子性的操作被称为原子操作。原子操作是指一系列的操作，要么全部发生，要么全部不发生，不会出现执行一半就终止的情况。\n内存可见性：因为多级缓存引起，每个CPU获取数据，会将数据从内存一层层往上读取，同样，后续对于数据的修改也是先写入到自己的 L1 缓存中，然后等待时机再逐层往下同步，直到最终刷回内存。volatile：对一个 volatile 变量的写操作 happen-before 后面对该变量的读操作。\nsynchronized 不仅保证了原子性，还保证了可见性synchronized 不仅保证了临界区内最多同时只有一个线程执行操作，同时还保证了在前一个线程释放锁之后，之前所做的所有修改，都能被获得同一个锁的下一个线程所看到，也就是能读取到最新的值。因为如果其他线程看不到之前所做的修改，依然也会发生线程安全问题。\n"}]